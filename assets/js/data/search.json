[ { "title": "Distributed Systems Notes", "url": "/posts/LearnDistributedSystems/", "categories": "Courses, Distributed System", "tags": "Go Instant messaging System Programming", "date": "2022-10-09 22:28:00 +0000", "snippet": "1. RPC and Multi-Threadsreason for multi-threads: I/O concurrency Parallelism(multiple cores, true parallelism, multiple cpu cycles per second) Convenience(fire something every some seconds in loop waiting for separate work; notice to exit every routine gracefully! otherwise accumulating in background!)what if not use multi-threads while still enabling multiple servers to communicate with various clients?Async programming/Event-Driven programmingsingle thread, single loop waiting for any input/event/timer fireinteresting: use multiple cores, each responsible for an event-driven loop, can also act like multi-threadsprocess vs threadProcess: a single programming you are running. In a go program, it will create one UNIX process and one memory area. When you create many go routines, these threads will run sitting in this process within same memory space.Example: URL crawler// should have a record of the URLs, otherwise keep crawling because pages in URL is cyclic// Serial Crawlerfunc Serial(url string, fetcher Fetcher, fetched map[string]bool) { // use a pointer of the map, not copy to prevent duplicated search if fetched[url] { return } fetched[url] = true urls, err := fetcher.Fetch(url) if err != nil { return } for _, u := range urls { Serial(u, fetcher, fetched) // what if change to go Serial(u, fetcher, fetched)? // only print one page because the main function will return, not waiting } return}// concurrent crawler with shared state and Mutextype fetchState struct { mu sync.Mutex fetched map[string]bool}func ConcurrentMutex(url string, fetcher Fetcher, f *fetchState) { f.mu.Lock() already := f.fetched[url] f.fetched[url] = true f.mu.Unlock() if already { return } urls, err := fetcher.Fetch(url) if err != nil { return } var done sync.WaitGroup for _, u := range urls { // done.Add(1) done.Add(1) go func(url string) { ConcurrentMutex(u, fetcher, f) defer done.Done() // decrement the done counter // use defer to call done no matter whether ConcurrentMutex will be executed successfully }(u) // here, the string parameter is a value copy of the outer u, not pointer // because string is immutable. Otherwise, the u will change in the outer for loop, and will change the u in the inner function! } done.Wait() // wait the counter to down to zero return}Q: If the surrounding function returns, what will happen to the inner function’s reference to variables in surrounding function?In go, the compiler will analyze the inner function(also called closured function) and allocate a heap memory for the variable. So the inner function can still get it and the gabbage collecter is responsible for noticing the last function to refer the little piece of heap and when it returns and releases then.Q: race detector in goIt allocates sort of shadow memory, (huge memory) almost for every memory location and keeps track of which thread read/write the memory location. And keep tracking of requiring/releasing locks and doing other synchronization activities/forcing other threads to not run concurrently. If it detects one of the location is written while another thread is reading the memory without a lock notation, it will release error. (Not static analyzing, but watching what happens in a particular part of the program. If this part didn’t execute some code, like reading or writing a shared data, the race detector will never know whether there could be a race. So we need to set up some sort of a testing apparatus to make sure all the codes can be executed.) Actually the detector didn’t see the interleaving/simultaneous execution, it just use the shadow memory to detect possible simultaneous read/write race without lock.Q: How many threads?In practical, there will be billions of urls, and to create billions of threads(too many memory, not feasible). Solution: pre-create a fixed size of pools of workers and have workers iteratively crawl.Use channel for concurrent crawling// no need to worry about shared memory by using channelfunc worker(url string, ch chan []string, fetcher Fetcher) { urls, err := fetcher.Fetch(url) if err != nil { ch &lt;- []string{} } else { ch &lt;- urls }}func master(ch chan []string, fetcher Fetcher) { // the master that use the channel n := 1 fetched := make(map[string]bool) // range: keep waiting until receive a new channel // if the channel is not closed, range will keep blocking // only condition to return is when n==0 for urls := range ch { for _, u := range urls { if fetched[u] == false { fetched[u] == true // n add 1 for each worker n+=1 go worker(u, ch, fetcher) } } n -= 1 // n=0, meaning no one is using the channel anymore if n == 0 { break } }}func ConcurrentChannel(url string, fetcher Fetcher) { ch := make(chan []string) go func() { ch &lt;- []string{url} }() master(ch, fetcher)}" }, { "title": "Distributed System__Instant messaging system mode", "url": "/posts/GoMessagingSystem/", "categories": "Courses, Distributed System", "tags": "Go Instant messaging System Programming", "date": "2022-09-12 19:39:00 +0000", "snippet": "Demo1: Instant messaging system - Serverreference1. Construct basic Serverserver.go, contains following; Server Struct, containing Ip, Port NewServer(ip String, port int) method to create server object (s *Server) Start() Start Server method (s *Server) Handler(conn net.Conn) handle connectionpackage mainimport ( \"fmt\" \"net\")type Server struct { Ip string Port int}// 创建一个server的接口func NewServer(ip string, port int) *Server { server := &amp;Server{ Ip: ip, Port: port, } return server}func (s *Server) Handler(conn net.Conn) { // 当前连接的业务 fmt.Println(\"Connected Successfully!\")}// 启动服务器的接口func (s *Server) Start() { // socket listen listener, err := net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", s.Ip, s.Port)) if err != nil { fmt.Println(\"net.Listen err: \", err) return } // close listen socket defer listener.Close() for { // accpet conn, err := listener.Accept() if err != nil { fmt.Println(\"listener accept err: \", err) continue } // do handler go s.Handler(conn) }}main.go , start the Server:package mainfunc main() { server := NewServer(\"127.0.0.1\", 8888) server.Start()}Linux or MacOS command:build these two file: go build -o server main.go server.gorun: ./serverlisten to the service: nc 127.0.0.1 88882. User online functionuser.go: NewUser(conn net.Conn) *User 创建一个 user 对象 (u *User) ListenMessage() 监听 user 对应的 channel 消息```gotype User struct { Name string Addr string C chan string conn net.Conn}// 创建一个用户的APIfunc NewUser(conn net.Conn) *User { // from server accept, remote address is user’s address itself userAddr := conn.RemoteAddr().String()user := &amp;User{ Name: userAddr, Addr: userAddr, C: make(chan string), conn: conn,}// 启动监听当前user channel消息的goroutinego user.ListenMessage()return user }// 监听当前user channel的方法，一旦有消息，直接发送给客户端func (u *User) ListenMessage() { for { msg := &lt;-u.C u.conn.Write([]byte(msg + “\\n”)) }}server.go:- Add OnlineMap and Message fields- Create and add new user when handling client connection- Add listen and broadcast channel method- use a goroutine to listen Message```go/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-06 03:00:10 * @LastEditTime: 2022-09-11 23:03:11 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /learnGo/14_golang_IM_System/server.go */package mainimport (\t\"fmt\"\t\"net\"\t\"sync\")type Server struct {\tIp string\tPort int\t// online user's map\tOnlineMap map[string]*User\tmapLock sync.RWMutex\t// broadcast channel\tMessage chan string}// A server objectfunc NewServer(ip string, port int) *Server {\t// var server *Server\tserver := &amp;Server{\t\tIp: ip,\t\tPort: port,\t\tOnlineMap: make(map[string]*User),\t\tMessage: make(chan string),\t}\treturn server}// goroutine to listen the message channel to send to all online userfunc (s *Server) ListenMessage() {\tfor {\t\tmsg := &lt;-s.Message\t\t// send msg to all online user\t\ts.mapLock.Lock()\t\tfor _, cli := range s.OnlineMap {\t\t\tcli.C &lt;- msg\t\t}\t\ts.mapLock.Unlock()\t}}// method to broadcast msgsfunc (s *Server) Broadcast(user *User, msg string) {\tsendMsg := \"[\" + user.Addr + \"]\" + user.Name + \":\" + msg\ts.Message &lt;- sendMsg}func (s *Server) Handler(conn net.Conn) {\t// ... current connect business\tfmt.Println(\"Connect successfully!\")\tuser := NewUser(conn)\t// user online, add user to onlineMap\ts.mapLock.Lock()\ts.OnlineMap[user.Name] = user\ts.mapLock.Unlock()\t// broadcast current user's online msg\ts.Broadcast(user, \"Online!\")\t// handler block\tselect {}}func (s *Server) Start() {\t// socket listen\tListener, err := net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", s.Ip, s.Port))\tif err != nil {\t\tfmt.Println(\"net.Listen err:\", err)\t\treturn\t}\t// close listen socket\tdefer Listener.Close()\t// Start listen Message goroutine\tgo s.ListenMessage()\tfor {\t\t// accept\t\tconn, err := Listener.Accept()\t\tif err != nil {\t\t\tfmt.Println(\"net.Listen err:\", err)\t\t\tcontinue\t\t}\t\t// dp handler\t\tgo s.Handler(conn)\t}}结构体中的channel基本都需要开一个循环去监听其变化（尝试取出值，发送给其他channel）3. Broadcast clients’ messagesserver.go: Improve the handle processing business method and start a read routine for the current client/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-06 03:00:10 * @LastEditTime: 2022-09-11 23:18:59 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /learnGo/14_golang_IM_System/server.go */package mainimport (\t\"fmt\"\t\"io\"\t\"net\"\t\"sync\")type Server struct {\tIp string\tPort int\t// online user's map\tOnlineMap map[string]*User\tmapLock sync.RWMutex\t// broadcast channel\tMessage chan string}// A server objectfunc NewServer(ip string, port int) *Server {\t// var server *Server\tserver := &amp;Server{\t\tIp: ip,\t\tPort: port,\t\tOnlineMap: make(map[string]*User),\t\tMessage: make(chan string),\t}\treturn server}// goroutine to listen the message channel to send to all online userfunc (s *Server) ListenMessage() {\tfor {\t\tmsg := &lt;-s.Message\t\t// send msg to all online user\t\ts.mapLock.Lock()\t\tfor _, cli := range s.OnlineMap {\t\t\tcli.C &lt;- msg\t\t}\t\ts.mapLock.Unlock()\t}}// method to broadcast msgsfunc (s *Server) Broadcast(user *User, msg string) {\tsendMsg := \"[\" + user.Addr + \"]\" + user.Name + \":\" + msg\ts.Message &lt;- sendMsg}func (s *Server) Handler(conn net.Conn) {\t// ... current connect business\tfmt.Println(\"Connect successfully!\")\tuser := NewUser(conn)\t// user online, add user to onlineMap\ts.mapLock.Lock()\ts.OnlineMap[user.Name] = user\ts.mapLock.Unlock()\t// broadcast current user's online msg\ts.Broadcast(user, \"Online!\")\t// Receiver users' msgs\tgo func() {\t\tbuf := make([]byte, 4096)\t\tfor {\t\t\tn, err := conn.Read(buf)\t\t\tif n == 0 {\t\t\t\ts.Broadcast(user, \"Offline\")\t\t\t\t// ctrl + c: will kill the user pid, and broadcast offline to other users\t\t\t\t// return to end the routine, every user has one!\t\t\t\treturn\t\t\t}\t\t\tif err != nil &amp;&amp; err != io.EOF {\t\t\t\tfmt.Println(\"Conn Read err:\", err)\t\t\t\treturn\t\t\t}\t\t\t// extract msg (delete '\\n' in the end)\t\t\tmsg := string(buf[:n-1])\t\t\t// broadcast msg\t\t\ts.Broadcast(user, msg)\t\t}\t}()\t// handler block\tselect {}}func (s *Server) Start() {\t// socket listen\tListener, err := net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", s.Ip, s.Port))\tif err != nil {\t\tfmt.Println(\"net.Listen err:\", err)\t\treturn\t}\t// close listen socket\tdefer Listener.Close()\t// Start listen Message goroutine\tgo s.ListenMessage()\tfor {\t\t// accept\t\tconn, err := Listener.Accept()\t\tif err != nil {\t\t\tfmt.Println(\"net.Listen err:\", err)\t\t\tcontinue\t\t}\t\t// dp handler\t\tgo s.Handler(conn)\t}}4. Encapsulate user APIuser.go: Add server field in user struct Add Online, Offline, DoMessage methods/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-11 22:47:44 * @LastEditTime: 2022-09-11 23:35:04 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /learnGo/14_golang_IM_System/User.go */package mainimport \"net\"type User struct {\tName string\tAddr string\tC chan string\tconn net.Conn\tserver *Server}// 创建一个用户的APIfunc NewUser(conn net.Conn, server *Server) *User {\tuserAddr := conn.RemoteAddr().String()\tuser := &amp;User{\t\tName: userAddr,\t\tAddr: userAddr,\t\tC: make(chan string),\t\tconn: conn,\t\tserver: server,\t}\t// 启动监听当前user channel消息的goroutine\tgo user.ListenMessage()\treturn user}// user onlinefunc (u *User) Online() {\t// user online, add user to onlineMap\tu.server.mapLock.Lock()\tu.server.OnlineMap[u.Name] = u\tu.server.mapLock.Unlock()\t// broadcast online msg\tu.server.Broadcast(u, \"Online!\")}// user offlinefunc (u *User) Offline() {\t// user offline, delete it from onlineMap\tu.server.mapLock.Lock()\tdelete(u.server.OnlineMap, u.Name)\tu.server.mapLock.Unlock()\t// broadcast offline msg\tu.server.Broadcast(u, \"Offline!\")}// handle user msgfunc (u *User) DoMessage(msg string) {\tu.server.Broadcast(u, msg)}// 监听当前user channel的方法，一旦有消息，直接发送给客户端func (u *User) ListenMessage() {\tfor {\t\tmsg := &lt;-u.C\t\tu.conn.Write([]byte(msg + \"\\n\"))\t}}server.go: Use user API to replace code before/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-06 03:00:10 * @LastEditTime: 2022-09-11 23:36:35 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /learnGo/14_golang_IM_System/server.go */package mainimport (\t\"fmt\"\t\"io\"\t\"net\"\t\"sync\")type Server struct {\tIp string\tPort int\t// online user's map\tOnlineMap map[string]*User\tmapLock sync.RWMutex\t// broadcast channel\tMessage chan string}// A server objectfunc NewServer(ip string, port int) *Server {\t// var server *Server\tserver := &amp;Server{\t\tIp: ip,\t\tPort: port,\t\tOnlineMap: make(map[string]*User),\t\tMessage: make(chan string),\t}\treturn server}// goroutine to listen the message channel to send to all online userfunc (s *Server) ListenMessage() {\tfor {\t\tmsg := &lt;-s.Message\t\t// send msg to all online user\t\ts.mapLock.Lock()\t\tfor _, cli := range s.OnlineMap {\t\t\tcli.C &lt;- msg\t\t}\t\ts.mapLock.Unlock()\t}}// method to broadcast msgsfunc (s *Server) Broadcast(user *User, msg string) {\tsendMsg := \"[\" + user.Addr + \"]\" + user.Name + \":\" + msg\ts.Message &lt;- sendMsg}func (s *Server) Handler(conn net.Conn) {\t// ... current connect business\tfmt.Println(\"Connect successfully!\")\tuser := NewUser(conn, s)\t// user online, add user to onlineMap\tuser.Online()\t// broadcast current user's online msg\ts.Broadcast(user, \"Online!\")\t// Receiver users' msgs\tgo func() {\t\tbuf := make([]byte, 4096)\t\tfor {\t\t\tn, err := conn.Read(buf)\t\t\tif n == 0 {\t\t\t\tuser.Offline()\t\t\t\t// ctrl + c: will kill the user pid, and broadcast offline to other users\t\t\t\t// return to end the routine, every user has one!\t\t\t\treturn\t\t\t}\t\t\tif err != nil &amp;&amp; err != io.EOF {\t\t\t\tfmt.Println(\"Conn Read err:\", err)\t\t\t\treturn\t\t\t}\t\t\t// extract msg (delete '\\n' in the end)\t\t\tmsg := string(buf[:n-1])\t\t\t// broadcast msg\t\t\tuser.DoMessage(msg)\t\t}\t}()\t// handler block\tselect {}}func (s *Server) Start() {\t// socket listen\tListener, err := net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", s.Ip, s.Port))\tif err != nil {\t\tfmt.Println(\"net.Listen err:\", err)\t\treturn\t}\t// close listen socket\tdefer Listener.Close()\t// Start listen Message goroutine\tgo s.ListenMessage()\tfor {\t\t// accept\t\tconn, err := Listener.Accept()\t\tif err != nil {\t\t\tfmt.Println(\"net.Listen err:\", err)\t\t\tcontinue\t\t}\t\t// dp handler\t\tgo s.Handler(conn)\t}}5. Search online users and rename userName5.1 Search online usersif user inputs ‘who’, then return online users to himuser.go: Add send message API func (u *User) SendMsg(msg string) { u.conn.Write([]byte(msg))} In DoMessage() method, add function to handle “who” msg, output online users’ info func (u *User) DoMessage(msg string) { if msg == \"who\" { // look for current online users u.server.mapLock.Lock() for _, user := range u.server.OnlineMap { onlineMsg := \"[\" + user.Addr + \"]\" + user.Name + \":\" + \"Online...\\n\" u.SendMsg(onlineMsg) } u.server.mapLock.Unlock() } else { u.server.Broadcast(u, msg) }} 5.2 Rename userName if a user inputs “rename|zzp”, it will change his name to “zzp”user.go: In DoMessage() method, add case for handling “rename|xxx” func (u *User) DoMessage(msg string) { if msg == \"who\" { // look for current online users u.server.mapLock.Lock() for _, user := range u.server.OnlineMap { onlineMsg := \"[\" + user.Addr + \"]\" + user.Name + \":\" + \"Online...\\n\" u.SendMsg(onlineMsg) } u.server.mapLock.Unlock() } else if len(msg) &gt; 7 &amp;&amp; msg[:7] == \"rename|\" { // format:\"rename|xxx\" newName := strings.Split(msg, \"|\")[1] // check if newName has existed _, ok := u.server.OnlineMap[newName] if ok { u.SendMsg(\"This userName has been used!\\n\") } else { u.server.mapLock.Lock() delete(u.server.OnlineMap, newName) u.server.OnlineMap[newName] = u u.server.mapLock.Unlock() u.Name = newName u.SendMsg(\"You have updated the userName: \" + u.Name + \"\\n\") } } else { u.server.Broadcast(u, msg) }} 6. Close the user when exceeds time limitWhen a user hasn’t sent a msg for a long time, he will be kicked.server.go: In handler() goroutine, add islive channel, if the user send a message, add true func (s *Server) Handler(conn net.Conn) { // ... current connect business fmt.Println(\"Connect successfully!\") user := NewUser(conn, s) // user online, add user to onlineMap user.Online() //check whether user is alive islive := make(chan bool) // Receiver users' msgs go func() { buf := make([]byte, 4096) for { n, err := conn.Read(buf) if n == 0 { user.Offline() // ctrl + c: will kill the user pid, and broadcast offline to other users // return to end the routine, every user has one! return } if err != nil &amp;&amp; err != io.EOF { fmt.Println(\"Conn Read err:\", err) return } // extract msg (delete '\\n' in the end) msg := string(buf[:n-1]) // broadcast msg user.DoMessage(msg) islive &lt;- true } }() for { // select理解： 首先执行case右边语句并评估，都没有可行的就会阻塞，超过一个可行会随机选中case // 然后进入下一次轮询，每次轮询都会重新执行所有case右边语句并开始评估！ // 参考：https://www.cnblogs.com/f-ck-need-u/p/9994512.html select { // if islive, do nothing, and select will enter into next check, // also the time counting will be reset. // 把time.After() 写在里面的话，如果islive case选中，下一次轮询就会重置计时 case &lt;-islive: // current user is alive, do nothing and reset time in next check case &lt;-time.After(time.Second * 10): // time exceeds! kick the user user.SendMsg(\"You are kicked!\\n\") // close resources close(user.C) conn.Close() // exit return } } // handler block select {}} 7. Private communication modemsg format: to|name|contentwill send message to a specific userfunc (u *User) DoMessage(msg string) {\tif msg == \"who\" {\t\t// look for current online users\t\tu.server.mapLock.Lock()\t\tfor _, user := range u.server.OnlineMap {\t\t\tonlineMsg := \"[\" + user.Addr + \"]\" + user.Name + \":\" + \"Online...\\n\"\t\t\tu.SendMsg(onlineMsg)\t\t}\t\tu.server.mapLock.Unlock()\t} else if len(msg) &gt; 7 &amp;&amp; msg[:7] == \"rename|\" {\t\t// format:\"rename|xxx\"\t\tnewName := strings.Split(msg, \"|\")[1]\t\t// check if newName has existed\t\t_, ok := u.server.OnlineMap[newName]\t\tif ok {\t\t\tu.SendMsg(\"This userName has been used!\\n\")\t\t} else {\t\t\tu.server.mapLock.Lock()\t\t\tdelete(u.server.OnlineMap, newName)\t\t\tu.server.OnlineMap[newName] = u\t\t\tu.server.mapLock.Unlock()\t\t\tu.Name = newName\t\t\tu.SendMsg(\"You have updated the userName: \" + u.Name + \"\\n\")\t\t}\t} else if len(msg) &gt; 4 &amp;&amp; msg[:3] == \"to|\" {\t\t// msg format: to|zzp|content\t\t// 1. get receiver's username\t\tremoteName := strings.Split(msg, \"|\")[1]\t\tif remoteName == \"\" {\t\t\tu.SendMsg(\"Please give a valid name! format is to|name|content\\n\")\t\t\treturn\t\t}\t\t// 2. According to the username, get the user object\t\tremoteUser, ok := u.server.OnlineMap[remoteName]\t\tif !ok {\t\t\tu.SendMsg(\"This user doesn't exist!\\n\")\t\t\treturn\t\t}\t\t// 3. remoteUser exists, send msg to remoteUser\t\tcontent := strings.Split(msg, \"|\")[2]\t\tif content == \"\" {\t\t\tu.SendMsg(\"Content is not valid\\n\")\t\t\treturn\t\t} else {\t\t\tremoteUser.SendMsg(u.Name + \" says:\" + content)\t\t}\t} else {\t\tu.server.Broadcast(u, msg)\t}}Demo2: Instant messaging system - ClientDefine client struct and connectionclient.go:/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-13 00:05:29 * @LastEditTime: 2022-09-13 00:12:57 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /learnGo/14_golang_IM_System/client.go */package mainimport (\t\"fmt\"\t\"net\")type Client struct {\tServerIp string\tServerPort int\tName string\tconn net.Conn}func NewClient(serverIp string, serverPort int) *Client {\t// create a new client object\tclient := &amp;Client{\t\tServerIp: serverIp,\t\tServerPort: serverPort,\t}\t// connect to server\tconn, err := net.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", serverIp, serverPort))\tif err != nil {\t\tfmt.Println(\"net.Dial error: \", err)\t\treturn nil\t}\tclient.conn = conn\t// return object\tfmt.Println(\"Connect successfully! localaddr:\")\tfmt.Println(conn.LocalAddr())\tfmt.Println(\"Connect successfully! Remoteaddr:\")\tfmt.Println(conn.RemoteAddr())\treturn client}func main() {\tclient := NewClient(\"127.0.0.1\", 8888)\tif client == nil {\t\tfmt.Println(\"&gt;&gt;&gt; connect fail!\")\t\treturn\t}\tfmt.Println(\"&gt;&gt;&gt; Connect succeeds!\")\tselect {}}go build -o client client.gorun: ./clientParse command lineInitialize command line args and parse them in init functionvar serverIp stringvar serverPort intfunc init() {\tflag.StringVar(&amp;serverIp, \"ip\", \"127.0.0.1\", \"Set server ip addr(default: 127.0.0.1)\")\tflag.IntVar(&amp;serverPort, \"port\", 8888, \"Set server port(default: 8888)\")\t// parse command line\tflag.Parse()}in main function:client := NewClient(serverIp, serverPort)Can parse args in command line to run client./client -h : get help./client -ip 127.0.0.1 -port 8888Menu displayadd new flag field in client struct:type Client struct {\tServerIp string\tServerPort int\tName string\tconn net.Conn\tflag int // current client mode}add menu function to get inputfunc (client *Client) menu() bool {\tvar flag int\tfmt.Println(\"1. Public messaging mode\")\tfmt.Println(\"2. Private messaging mode\")\tfmt.Println(\"3. Update userName\")\tfmt.Println(\"0. Exit\")\tfmt.Scanln(&amp;flag)\tif flag &gt;= 0 &amp;&amp; flag &lt;= 3 {\t\tclient.flag = flag\t\treturn true\t} else {\t\tfmt.Println(\"&gt;&gt;&gt; Please enter valid number (0 ~ 3)\")\t\treturn false\t}}add run() to loop main business:func (client *Client) Run() {\tfor client.flag != 0 {\t\tfor !client.menu() {\t\t}\t\t// Handle different business\t\tswitch client.flag {\t\tcase 1:\t\t\t// Public\t\t\tfmt.Println(\"Public\")\t\t\tbreak\t\tcase 2:\t\t\t// Private\t\t\tfmt.Println(\"Private\")\t\tcase 3:\t\t\t// Update user name\t\t\tfmt.Println(\"Update user name\")\t\t}\t}\tfmt.Println(\"Exit!\")}add flag in new client function:func NewClient(serverIp string, serverPort int) *Client {\t// create a new client object\tclient := &amp;Client{\t\tServerIp: serverIp,\t\tServerPort: serverPort,\t\tflag: 999, // if 0, will exit directly!\t}\t// connect to server\tconn, err := net.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", serverIp, serverPort))\tif err != nil {\t\tfmt.Println(\"net.Dial error: \", err)\t\treturn nil\t}\tclient.conn = conn\t// return object\tfmt.Println(\"Connect successfully! localaddr:\")\tfmt.Println(conn.LocalAddr())\tfmt.Println(\"Connect successfully! Remoteaddr:\")\tfmt.Println(conn.RemoteAddr())\treturn client}Update user nameAdd UpdateName() function to update user name:func (client *Client) UpdateName() bool {\tfmt.Println(\"&gt;&gt;&gt;Please input username: \")\tfmt.Scanln(&amp;client.Name)\tsendMsg := \"rename|\" + client.Name + \"\\n\" // encapsulate protocal\t_, err := client.conn.Write([]byte(sendMsg)) // server will read the msg and handle it\tif err != nil {\t\tfmt.Println(\"conn.Write err: \", err)\t\treturn false\t}\treturn true}Add DealResponse() method to handle server’s response msgReason: the run() method will always block for input, need another goroutine to handle server’s responsefunc (client *Client) DealResponse() {\tio.Copy(os.Stdout, client.conn)\t// be like following: Once client.conn has data can read, copy to stdout, always block and listen!\t// for {\t// \tbuf := make()\t// \tclient.conn.Read(buf)\t// \tfmt.Println(\"\")\t// }}Open a goroutine in main, to deal with response!func main() {\tclient := NewClient(serverIp, serverPort)\tif client == nil {\t\tfmt.Println(\"&gt;&gt;&gt; connect fail!\")\t\treturn\t}\t// open a goroutine to handle server's feedback msg\tgo client.DealResponse()\tfmt.Println(\"&gt;&gt;&gt; Connect succeeds!\")\tclient.Run()\tselect {}}Public messaging modeAdd PublicChat():func (client *Client) PublicChat() {\t// user input msg\tvar chatMsg string\tfmt.Println(\"&gt;&gt;&gt; Please enter msg, input exit to exit\")\tfmt.Scanln(&amp;chatMsg)\tfor chatMsg != \"exit\" {\t\t// send to server\t\t// msg != null, send at once\t\tif len(chatMsg) != 0 {\t\t\tsendMsg := chatMsg + \"\\n\"\t\t\t_, err := client.conn.Write([]byte(sendMsg))\t\t\tif err != nil {\t\t\t\tfmt.Println(\"conn Write err: \", err)\t\t\t\tbreak\t\t\t}\t\t}\t\tchatMsg = \"\"\t\tfmt.Println(\"&gt;&gt;&gt; Please enter msg, input exit to exit\")\t\tfmt.Scanln(&amp;chatMsg)\t}}Private chatting modeSearch online clients:func (client *Client) SelectUsers() {\tsendMsg := \"who\\n\"\t_, err := client.conn.Write([]byte(sendMsg))\tif err != nil {\t\tfmt.Println(\"conn Write err: \", err)\t\treturn\t}}Add private mode:func (client *Client) PrivateChat() {\tvar remoteName string\tvar chatMsg string\tclient.SelectUsers()\tfmt.Println(\"&gt;&gt;&gt;&gt;请输入聊天对象的[用户名], exit退出: \")\tfmt.Scanln(&amp;remoteName)\tfor remoteName != \"exit\" {\t\tfmt.Println(\"&gt;&gt;&gt;&gt;请输入消息内容，exit退出:\")\t\tfmt.Scanln(&amp;chatMsg)\t\tfor chatMsg != \"exit\" {\t\t\t// 消息不为空则发送\t\t\tif len(chatMsg) != 0 {\t\t\t\tsendMsg := \"to|\" + remoteName + \"|\" + chatMsg + \"\\n\\n\"\t\t\t\t_, err := client.conn.Write([]byte(sendMsg))\t\t\t\tif err != nil {\t\t\t\t\tfmt.Println(\"conn Write err: \", err)\t\t\t\t\tbreak\t\t\t\t}\t\t\t}\t\t\tchatMsg = \"\"\t\t\tfmt.Println(\"&gt;&gt;&gt;&gt;请输入消息内容，exit退出:\")\t\t\tfmt.Scanln(&amp;chatMsg)\t\t}\t\tclient.SelectUsers()\t\tfmt.Println(\"&gt;&gt;&gt;&gt;请输入聊天对象的[用户名], exit退出: \")\t\tfmt.Scanln(&amp;remoteName)\t}}" }, { "title": "Distributed System__Java Web Programming Practice", "url": "/posts/JavaWeb/", "categories": "Courses, Distributed System", "tags": "Java Web Programming", "date": "2022-09-11 03:39:00 +0000", "snippet": "Port(PID)netstat -ano #查看所有端口netstat -ano|findstr \"6732\" #查看指定端口tasklist|findstr \"6732\" #查看指定进程# 使用任务管理器查看PID端口号与IP地址的组合，得出一个网络套接字:Socket，所以说一些网络编程也被称为Socket编程import java.net.InetSocketAddress;public class InetSocketAddressTest { public static void main(String[] args) { InetSocketAddress socketAddress = new InetSocketAddress(\"127.0.0.1\",8080); InetSocketAddress socketAddress2 = new InetSocketAddress(\"localhost\",9000); System.out.println(socketAddress.getHostName()); System.out.println(socketAddress.getAddress()); System.out.println(socketAddress.getPort()); System.out.println(socketAddress2.getHostName()); System.out.println(socketAddress2.getAddress()); //返回地址 System.out.println(socketAddress2.getPort()); //返回端口 } }Protocal1. TCP Demo1.1 Client Demo1import java.io.IOException;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;import java.net.UnknownHostException;//客户端public class TcpClientDemo01 { public static void main(String[] args) { Socket socket = null; OutputStream os = null; try { //1. 连接服务器的地址 InetAddress serverIP = InetAddress.getByName(\"127.0.0.1\"); int port = 8899; //2. 创建一个Socket socket = new Socket(serverIP,port); //3. 创建一个输出流，向外写东西 os = socket.getOutputStream(); os.write(\"你好,欢迎学习狂神说Java\".getBytes()); } catch (UnknownHostException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { //4. 关闭资源 try { if (os!=null){ os.close(); } if (socket!=null){ socket.close(); } } catch (IOException e) { e.printStackTrace(); } } }}1.2. Server Demo1import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;//服务端public class TcpServerDemo01 { public static void main(String[] args) { ServerSocket serverSocket = null; Socket accept = null; InputStream is = null; ByteArrayOutputStream baos = null; try { //1. 开放服务器端口，创建ServerSocket serverSocket = new ServerSocket(8899); while (true) { //2. 等待客户端的连接 accept = serverSocket.accept(); //3. 读入客户端的消息, is = accept.getInputStream(); /* 回忆之前的IO流方案，弊端:存在中文，可能存在乱码。 byte[] buffer = new byte[1024]; int len; while ((len=is.read(buffer))!=-1){ String str = new String(buffer,0,len); System.out.println(str); } **/ baos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len; while ((len=is.read(buffer))!=-1){ baos.write(buffer,0,len); } System.out.println(baos.toString()); System.out.println(\"数据来源地址:\"+accept.getInetAddress().getHostName()); } } catch (IOException e) { e.printStackTrace(); } finally { //4. 关闭资源 try { if (baos!=null){ baos.close(); } if (is!=null){ is.close(); } if (accept!=null){ accept.close(); } if (serverSocket!=null){ serverSocket.close(); } }catch (Exception e) { e.printStackTrace(); } } }}1.3 Client Demo2/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-10 15:33:20 * @LastEditTime: 2022-09-11 02:43:36 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /JavaWebPractice/TcpClientDemo02.java */import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.InputStream;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;public class TcpClientDemo02 { public static void main(String[] args) throws Exception { // 1. 创建server连接 Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"), 9090); // 2. 创建一个输出流 OutputStream os = socket.getOutputStream(); // 3. 读取文件 FileInputStream fis = new FileInputStream(new File(\"textfile.txt\")); // 4. 写出文件 byte[] buffer = new byte[1024]; int len; // file has EOF, so fis.read() will not block while ((len = fis.read(buffer)) != -1) { os.write(buffer, 0, len); } // tell server the output stream is over and close output, // otherwise server will always be waiting socket.shutdownOutput(); // wait for server to reply, and respond to console // System.out.println(\"I can get there!\"); InputStream inputStream = socket.getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer2 = new byte[1024]; int len2; // Why server doesn't shut down its outputStream but this won't get blocked? // because the server will end its function and close, then the inputStream will not block while ((len2 = inputStream.read(buffer2)) != -1) { baos.write(buffer2, 0, len2); // System.out.println(\"I can get there!\"); } System.out.println(\"I can get there!\"); System.out.println(baos.toString()); // 5. 资源关闭，应该使用try-catch-finally baos.close(); inputStream.close(); fis.close(); os.close(); socket.close(); }}1.4 Server Demo2/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-10 15:33:28 * @LastEditTime: 2022-09-11 02:40:41 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /JavaWebPractice/TcpServerDemo02.java */import java.io.File;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;import java.util.concurrent.TimeUnit;public class TcpServerDemo02 { public static void main(String[] args) throws Exception{ // 1. open serverSocket ServerSocket serverSocket = new ServerSocket(9090); // 2. listen client socket Socket socket = serverSocket.accept(); // 3. get inputStream InputStream is = socket.getInputStream(); // 4. read file and writer to a new file FileOutputStream fos = new FileOutputStream(new File(\"receive.txt\")); byte[] buffer = new byte[1024]; int len; // inputStream read is block function, unless outputStream shut down or closed, will always blocked, // not even get into the while loop once. while ((len = is.read(buffer)) != -1) { // System.out.println(\"I can get there!\"); fos.write(buffer, 0, len); } System.out.println(\"I can get there!\"); // tell client receive successfully OutputStream outputStream = socket.getOutputStream(); outputStream.write(\"File has been received successfully!\".getBytes()); TimeUnit.SECONDS.sleep(1); outputStream.write(\"Can you receive this?\".getBytes()); // 5. close, should use try-catch-finally outputStream.close(); fos.close(); is.close(); socket.close(); serverSocket.close(); }}2. UDP Demo2.1 说明 DatagramSocket 和 DatagramPacket 两个类实现了基于UDP协议的网络程序。 UDP 数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证UDP数据报一定能够安 全送到目的地，也不确定什么时候可以抵达。 DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端 的IP地址和端口号。 UDP协议中每个数据报都给出了完整的地址信息，因此无需建立发送方和接收方的连接。如同发快递包裹一样。2.2 Demo1 TalkingSenderimport java.io.BufferedReader;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-10 17:01:23 * @LastEditTime: 2022-09-10 17:12:10 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /JavaWebPractice/UdpSenderDemo01.java */public class UdpSenderDemo01 { public static void main(String[] args) throws Exception{ System.out.println(\"Sender start...\"); // 1. create DatagramSocket DatagramSocket socket = new DatagramSocket(8888); // 2. encapsulate data packet // String msg = \"Udpsender==&gt;\"; // byte[] data = msg.getBytes(); // InetAddress inet = InetAddress.getByName(\"127.0.0.1\"); // int port = 9090; // // args: byte[], offset, length, socket(address, port) // DatagramPacket packet = new DatagramPacket(data, 0, data.length, inet, port); // 2. encapsulate data packet from console input BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); while (true) { String data = reader.readLine(); byte[] datas = data.getBytes(); // 3. encapsulate datas to DatagramPacket, send to destination DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(\"localhost\", 6666)); // 4. send packet to receiver socket.send(packet); // exit check if (data.equals(\"bye\")) { break; } } // 5. close reader.close(); socket.close(); }}Receiver/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-10 17:12:28 * @LastEditTime: 2022-09-10 17:18:21 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /JavaWebPractice/UdpReceiverDemo01.java */import java.net.DatagramPacket;import java.net.DatagramSocket;public class UdpReceiverDemo01 { public static void main(String[] args) throws Exception{ DatagramSocket socket= new DatagramSocket(6666); while(true) { try { byte[] container = new byte[1024]; DatagramPacket packet = new DatagramPacket(container, 0, container.length); socket.receive(packet); // receive packet(block) byte[] datas = packet.getData(); int len = packet.getLength(); String data = new String(datas, 0, len); System.out.println(data); // exit check if (data.equals(\"bye\")) { break; } } catch (Exception e) { e.printStackTrace(); } } socket.close(); }}2.3 Demo2 Multi-thread TalkingSenderThread/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-10 23:01:28 * @LastEditTime: 2022-09-10 23:09:24 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /JavaWebPractice/TalkSend.java */import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;public class TalkSend implements Runnable { private DatagramSocket socket; private BufferedReader reader; private String toIp; private int toPort; public TalkSend(int port, String toIp, int toPort) { this.toIp = toIp; this.toPort = toPort; try { socket = new DatagramSocket(port); reader =new BufferedReader(new InputStreamReader(System.in)); } catch (Exception e) { e.printStackTrace(); } } @Override public void run() { while (true) { try { String data = reader.readLine(); byte[] datas = data.getBytes(); DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(this.toIp, this.toPort)); socket.send(packet); if (data.equals(\"bye\")) { break; } } catch (Exception e) { e.printStackTrace(); } } socket.close(); }}ReceiverThread/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-10 22:24:18 * @LastEditTime: 2022-09-10 23:01:08 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /JavaWebPractice/TalkReceive.java */import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.SocketException;public class TalkReceive implements Runnable { private DatagramSocket socket; private String msgFrom; public TalkReceive(int port, String msgFrom) { this.msgFrom = msgFrom; try { socket = new DatagramSocket(port); } catch (SocketException e) { e.printStackTrace(); } } @Override public void run() { while (true) { try { // prepare to receive packet byte[] container = new byte[1024]; DatagramPacket packet = new DatagramPacket(container, 0, container.length); socket.receive(packet); // block to receive packet byte[] datas = packet.getData(); int len = packet.getLength(); String data = new String(datas, 0, len); System.out.println(msgFrom + \":\" + data + \" from address: \" + packet.getAddress()); // exit check if (data.equals(\"bye\")) { break; } } catch (Exception e) { e.printStackTrace(); } } socket.close(); }}Student/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-10 23:09:43 * @LastEditTime: 2022-09-10 23:20:04 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /JavaWebPractice/TalkStudent.java */public class TalkStudent { public static void main(String[] args) { new Thread(new TalkSend(7777, \"localhost\", 9999)).start(); new Thread(new TalkReceive(8888, \"老师\")).start(); }}Teacher/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-10 23:10:56 * @LastEditTime: 2022-09-10 23:12:09 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /JavaWebPractice/TalkTeacher.java */public class TalkTeacher { public static void main(String[] args) { new Thread(new TalkReceive(9999, \"学生\")).start(); new Thread(new TalkSend(5555, \"localhost\", 8888)).start(); }}URLURL (Uniform Resource Locator): 统一资源定位符，它表示 internet 上某一资源的地址。它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate:定位这个资源。通过URL, 我们可以访问Internet上的各种网络资源，比如最常见的 www, ftp 站点。浏览器通过解析给定的URL可以在网络上查找相应的文件或其他资源。URL的基本结构由5部分组成:传输协议://主机名:端口号/文件名 #片段名?参数列表URL Demo/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-11 00:30:43 * @LastEditTime: 2022-09-11 00:47:45 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /JavaWebPractice/URLDemo01.java */import java.io.FileOutputStream;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.URL;public class URLDemo01 { public static void main(String[] args) { try { // 1. locate to ressource of server URL url = new URL(\"https://p1.music.126.net/7DYwgmJyEoTJZ3pyr7lixw==/109951167430870270.jpg?param=40y40\"); System.out.println(url.getProtocol()); //获取URL的协议名 System.out.println(url.getHost()); //获取URL的主机名 System.out.println(url.getPort()); //获取URL的端口号 System.out.println(url.getPath()); //获取URL的文件路径 System.out.println(url.getFile()); //获取URL的文件名 System.out.println(url.getQuery()); //获取URL的查询名 // 2. create connect HttpURLConnection connection = (HttpURLConnection) url.openConnection(); // 3. get inputStream InputStream is = connection.getInputStream(); // 4. write in file FileOutputStream fos = new FileOutputStream(\"icon.png\"); byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer)) != -1) { fos.write(buffer, 0, len); } // close fos.close(); is.close(); connection.disconnect(); System.out.println(\"closed...\"); } catch (Exception e) { e.printStackTrace(); } }}" }, { "title": "Foundations of Blockchains_18635 Note", "url": "/posts/SmallGame/", "categories": "Courses, Foundations of Blockchains_18635", "tags": "Blockchains", "date": "2022-08-31 02:30:00 +0000", "snippet": "An interesting card love dating game:Target: Alice and Bob, if both love each other, dating; otherwise, not datingPrerequisite:honest-but-curious, can’t be ‘malicious’Method 1:❤️: love ♣️: not loveStep 1: Alice went into the room, puts card face-down on table, ❤️ if love, ♣️ if no loveStep 2: Alice leaves the room, Bob went into the room, if he loves Alice, open the card and get the result; otherwise, do nothing.Step 3: Bob return to tell Alice if they would date.It is like ‘And’ function, only 1 will make an affect on the result. So if the person inputs 1, he/she should watch the other’s option; if the input is 0, then the result must be failure, so there is no need to watch the other’s choice and thus protecting the privacy of the other one that may have ❤️.Method 2:Solution2Secure 2-party computationAlice and Bob want to learn some function on their joint inputs without disclosing their inputs, how to do it without cards? how to do it for any function?" }, { "title": "Markdown+Typora学习笔记", "url": "/posts/typora/", "categories": "Tools Manual", "tags": "manual", "date": "2022-08-26 04:15:00 +0000", "snippet": "[TOC][Markdown+Typora/VSCode Manual]来源:Markdown-Typora-VSCode-Doc😂 简要介绍Markdown 是一种轻量型标记语言, 是一种语法. 以 .md 结尾的文本文件就是 Markdown 文件. 相较于 Word, 它更加像是 HTML 语言或是 $\\LaTeX$, 并不是最淳朴的那种”所见即所得”. 它处处透露着一种极简主义. 高效简洁清晰的同时, 又很简单. 看起来舒服, 语法简单, 尤其在处理纯文本上有很大的优势.它相较于 Word, 兼容性非常高, 可以跨平台使用, 不用担心奇奇怪怪的版本兼容问题. 同时, 有许多网站都支持或正在使用 Markdown 语法. 如 Github (等一系列代码托管平台), StackOverflow(等答疑平台), 简书, 语雀 (等一系列笔记平台).📐 实际应用所有要写文本的时候都可以用上 Markdown!它可以让你不再纠结什么字体, 什么样式, 什么排版. 而且逻辑清晰, 层次分明.像我大一的时候就用 Markdown 来写各种笔记, 演讲稿, 课程论文, 实验报告, 代码的 README.md … 包括本教程文档.🍴 工具Markdown 只是一种语法. 那么用来写 Markdown 的文本编辑器呢? 我推荐的是 Typora 或者 VS CodeTyporaTypora 应该是被广泛用于写 Markdown 的文本软件, 就和 Markdown 语法一样高效. 而且它还有很实用的扩展语法与自定义样式的功能. 其能将 .md 导出成多种文件, 如 .pdf, .html, .docx (没想到吧, 能导出到 Word)但是现在 Typora 已经发布正式版并且变为收费软件. 中文官网在此 Typora 官方中文站 .我当然是推荐大家都用正版啦. 不过价格是永久版￥89, 好在可以用在3台设备上. 如果和你的两位同学/舍友均摊一下, 每人就只要￥30, 和一张游戏月卡差不多.至于盗版以及破解方法在此随便找一种改注册表时间方法的不介绍(还挺多的其实).还有一种免费白嫖的方法就是安装测试版/Beta版. 官网有历史版本的下载链接 Typora 历史版本下载页白嫖Beta版已经寄了, 要么支持正版要么去学习一下破解方法吧 (还是忍不住啦, 看上面的链接👆)VS Code这是微软家的开源文本编辑器, 理论上来说所有代码, 语言, 都可以用 VS Code 来写, 同样是非常的简洁好用. 在下载插件 Markdown All in One 后对 Markdown 的基础支持也是非常的好. 若在 VS Code 下载 Markdown 各种附加扩展, 就能获得比 Typora 更加丰富的扩展语法与操作.其他大部分IDE, 像 Jetbrain 的全家桶里应该每一款, 都支持 Markdown 语法, 在此不多赘述.本文档主要使用 Typora 进行演示, 同时会介绍许多 Typora 所包含的扩展语法.🍭 基础教程当有多种标记方法时我会倾向其中一种.标题有 * 表示该为扩展语法, 仅在 Typora 或 添加了扩展的 VS Code 本地生效, 在大多数平台上并不认可.0. 写 Markdown 的第零步我们写文本的时候大多写的是中文, 可是输入法在输中文时使用的标点为全角标点, 如 ，。？！（）【】：；“”. 这些标点是不被 Markdown 所认可的, 也是无法转义的.我建议大家写 Markdown 的时候都用半角标点, 即英文标点, 如 ,.?!()[]:;\"\". 且每个半角标点在文本使用时加上后置空格, 符合英文标点的书写规范, 也更加美观.以微软自带输入法举例, 在使用中文输入法时按下 Ctrl + .(这是个句号), 切换标点的全角与半角. 这样即可中文输入+半角标点.1. 标题 [数个 “#” + 空格 前置]# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题标题会在目录与大纲分级显示, 可以跳转.在 Typora 中建议开启 严格模式, 即不应为 #标题, 应为 # 标题.应该要手动补上空格, 使得 Markdown 语法在其他文本编辑器上兼容.2. 强调 [用 “**” 或 “__” 包围]**欢迎报考南京大学!** (我喜欢用这种)__欢迎报考南京大学!__或者选中想要强调的文字按下 Ctrl + B.E.G.欢迎报考南京大学!3. 斜体 [用 “*” 或 “_” 包围]*欢迎大佬来浇浇我各种知识* (我喜欢用这种)_欢迎大佬来浇浇我各种知识_或者选中想要强调的文字按下 Ctrl + I.E.G.欢迎大佬来浇浇我各种知识(P.S. 斜体并强调 [用 “***” 或 “___” 包围])4. 删除线 [用 “~~” 包围]~~我宣布个事儿, 我是Sabiyary!~~E.G.我宣布个事儿, 我是Sabiyary!5. *高亮 [用 “==” 包围](注意: 此为扩展语法)==我喜欢黄色, 也喜欢绿色==E.G.==我喜欢黄色, 也喜欢绿色==6. 代码 [用 “`” 包围]`sudo rm -rf /*`E.G.sudo rm -rf /* (没事别乱敲这个! )“请输入管理员密码: (闪烁的光标)”7. 代码块 [按三个 “`” 并敲回车]```// 这里就可以开始输入你要的代码了#include &lt;stdio.h&gt;int mian() { print（“Hello, world!\\n\"）; retrun O;}``` // (这三个\"`\"文本编辑器会帮你自动补全 一般不用手动输)(我之前都是用这个来展示各种语法的, 应该不用举例了吧)要想显示行数的话, 一般要在 Typora 的设置里勾上这个显示行数的选项.代码块里可以选择语言, 其会根据语言来自动高亮各个语句. 在选择语言后, ` ` 会变为 ` + 对应语言.8. 引用 [”&gt;” + 空格 前置]&gt; 24岁, 是学生.&gt; &gt; 学生特有的无处不在(恼)引用是可以嵌套的!E.G. 24岁, 是学生. 学生特有的无处不在(恼) 9. 无序列表 [”-“ 或 “+” + 空格 前置]- 一颗是枣树 (我喜欢用这种)+ 另一颗还是枣树* (其实这种也可以, 不过由于在 Typora 中很难单个输入, 故不常用)三种前置符都可以, 敲回车会自动补全, 可在 Typora 设置中调整补全的符号, 敲回车后按下 Tab 会缩进一级.E.G. 一颗是枣树 另一颗还是枣树10. 有序列表 [数字 + “.” + 空格 前置]我来这里就为了三件事:1. 公平2. 公平3. 还是tm的公平!敲回车会自动补全, 敲回车后按下 Tab 会缩进一级.E.G.我来这里就为了三件事: 公平 公平 还是tm的公平!11. *上标 [用 “^” 包围](注意: 此为扩展语法)C语言中int的上限是 2^31^ - 1 = 2147483647E.G.C语言中 int 的上限是 2^31^ - 1 = 214748364712. *下标 [用 “~” 包围](注意: 此为扩展语法)H~2~O 是剧毒的!E.G.H~2~O 是剧毒的!13. *注释 [”[^]” 后置](注意: 此为扩展语法)&gt; 今日我们相聚于此, 是为了学习 Markdown 的使用, 它的教程对于全体「观众」而言, 值得足足两个硬币的支持鼓励![^1][^1]: 沃兹·基·硕德 改编自「公鸡」普契涅拉.需要在文末写上注释对应的内容E.G. 今日我们相聚于此, 是为了学习 Markdown 的使用, 它的教程对于全体「观众」而言, 值得足足两个硬币的支持鼓励!114. 链接 [常用 “[ ]” + “( )” 分别包围文本与链接](注意: 文内跳转为扩展用法)[来看看我贫瘠的仓库罢](https://github.com/Sakiyary)[基础教程: 12. 下标](#12. 下标 [用 \"~\" 包围])支持网页链接与文内跳转, 按住 Ctrl 并 单击鼠标左键 即可跳转.E.G.来看看我贫瘠的仓库罢[基础教程: 12. 下标](#12. 下标 [用 “~” 包围])15. 任务列表 [”- [ ]” + 空格 前置]TodoList:- [ ] 刷B站- [ ] 写代码- [x] 起床用 x 代替 [ ] 中的空格来勾选任务列表. 在 Typora 中可以直接用鼠标左键单击勾选框.E.G. TodoList: 刷B站 写代码 起床16. 表格 [用 “|” 绘制表格边框]| 学号 | 姓名 | 年龄 || :--- | :---: | ---: | (引号的位置代表着 左对齐, 居中, 右对齐)|114514|田所|24||1919810|浩三|25|第一行为表头, 并由第二行分割线决定对齐方式与长度, 第三行及之后即表格数据E.G. 学号 姓名 年龄 114514 田所 24 1919810 浩三 25 17. 图片 [直接拖进来或者复制粘贴]![图片](图片的位置)我还是会选择拖进来或者复制粘贴啦~ 在 Typora 的设置里也可以改图片的储存方式.18. 分割线 [按三个 “*” 或 “-“ 或 “_” 并敲回车]***--- (我喜欢用这种)___// (其实按三个及以上都可以)由于 * 与 _ 均会自动补全, 所以我觉得 - 最为方便.E.G.19. Emoji表情 [”:” 前置](注意: 英文输入为扩展语法):sweat_smile: :drooling_face::clown_face:// (敲回车或者鼠标点击, 后置的\":\"一般不需要手动输)这个功能唯一的要求就是英语水平要高, 或者大概记得各个 Emoji 的英文名.E.G.:sweat_smile: :drooling_face::clown_face:对于其余普通的 Markdown 文本编辑器, 可以直接将 Emoji 表情复制进来, 这是直接硬编码的 (刻进DNA里)E.G.😅🤤🤡用好这个功能可以让你的文本非常的可爱! 太抽象了这里分享一个可以复制全Emoji的网站, 非常好用! 我之前的C语言大作业也是从这里下载的资源!🔥 进阶教程1. 目录 [自动生成][TOC] (此为 Typora 特有的, 如本文档开头)若使用 VS Code 搭配 Markdown All in One 扩展, 可在 VS Code 的命令面板 (即 VS Code Command Palette) 输入 Create Table of Contents 自动生成目录, 且可在扩展设置中细调目录参数.2. 内联 HTML 代码 [用 “&lt;&gt; &lt;/&gt;” 包围]&lt;div style=\"text-align:center\"&gt; &lt;font style=\"color:red\"&gt;我不会 HTML 呜呜呜... 浇浇我&lt;/font&gt;&lt;/div&gt;&lt;center&gt;简单的文字居中也可以这样&lt;/center&gt;&lt;u&gt;我差点忘了还有下划线这东西...&lt;/u&gt;只要你会写, 你完全可以把 Markdown 当作 HTML 来写.同时, .md 文件可以直接导出成一个网页.下划线可以选中想要下划的文字按下 Ctrl + U.E.G. 我不会 HTML 呜呜呜... 浇浇我简单的文字居中也可以这样我差点忘了还有下划线这东西...3. 内联 $\\LaTeX$ 公式 [用 “$” 包围](注意: 部分编译器会不识别部分符号)$\\LaTeX$ 是最好用的论文排版语言! 不信你看!$a^n+b^n=c^n$$$%\\usepackage{unicode-math}\\displaystyle \\ointctrclockwise\\mathcal{D}[x(t)]\\sqrt{\\frac{\\displaystyle3\\uppi^2-\\sum_{q=0}^{\\infty}(z+\\hat L)^{q}\\exp(\\symrm{i}q^2 \\hbar x)}{\\displaystyle (\\symsfup{Tr}\\symbfcal{A})\\left(\\symbf\\Lambda_{j_1j_2}^{i_1i_2}\\Gamma_{i_1i_2}^{j_1j_2}\\hookrightarrow\\vec D\\cdot \\symbf P \\right)}}=\\underbrace{\\widetilde{\\left\\langle \\frac{\\notin \\emptyset}{\\varpi\\alpha_{k\\uparrow}}\\middle\\vert\\frac{\\partial_\\mu T_{\\mu\\nu}}{2}\\right\\rangle}}_{\\mathrm{K}_3\\mathrm{Fe}(\\mathrm{CN})_6} ,\\forall z \\in \\mathbb{R}$$用 $ 包围为单条公式, 按下两个 $ 并敲回车即生成公式块.E.G.$\\LaTeX$ 是最好用的论文排版语言! 不信你看!$a^n+b^n=c^n$\\[%\\usepackage{unicode-math}\\displaystyle \\ointctrclockwise\\mathcal{D}[x(t)]\\sqrt{\\frac{\\displaystyle3\\uppi^2-\\sum_{q=0}^{\\infty}(z+\\hat L)^{q}\\exp(\\symrm{i}q^2 \\hbar x)}{\\displaystyle (\\symsfup{Tr}\\symbfcal{A})\\left(\\symbf\\Lambda_{j_1j_2}^{i_1i_2}\\Gamma_{i_1i_2}^{j_1j_2}\\hookrightarrow\\vec D\\cdot \\symbf P \\right)}}=\\underbrace{\\widetilde{\\left\\langle \\frac{\\notin \\emptyset}{\\varpi\\alpha_{k\\uparrow}}\\middle\\vert\\frac{\\partial_\\mu T_{\\mu\\nu}}{2}\\right\\rangle}}_{\\mathrm{K}_3\\mathrm{Fe}(\\mathrm{CN})_6} ,\\forall z \\in \\mathbb{R}\\]4. *网络图床(这是学长给我的网络图床教程, 我并未实践过…)分享一个 Typora 搭配腾讯云COS/阿里云OSS图床的例子. 新用户免费试用6个月, 另外还可选择七牛云或者路过图床.5. *Typora 的常用快捷键 按键 效果 按键 效果 Ctrl + D 选中当前词 Ctrl + L 选中当前句/行 Ctrl + E 选中当前区块 Ctrl + F 搜索当前选中 Ctrl + B 加粗当前选中 Ctrl + H 替换当前选中 Ctrl + I 倾斜当前选中 Ctrl + U 下划当前选中 Ctrl + K 将当前选中生成链接 Ctrl + J 滚动屏幕将选中滚至顶部 Ctrl + W 关闭当前窗口 Ctrl + N 打开新窗口 Ctrl + O 打开文件 Ctrl + P 搜索文件并打开 Ctrl + 回车 表格下方插入行 Ctrl + , 打开偏好设置 Ctrl + . 切换全角/半角标点 Ctrl + / 切换正常/源代码视图 Ctrl + Shift + - 缩小视图缩放 Ctrl + Shift + + 放大视图缩放 还有一些不常用的/三键的快捷键不在此列出.6. *Typora 的主题样式与检查元素Markdown 在编译后约等于 HTML. 而 Typora 的正常视图就是编译后的 Markdown, 故Typora的主题样式本质就是 CSS 文件.可以下载各种好看的主题给 Typora换上, 同时也可以自己调整对应的 CSS 文件, 或者自己手搓.在 Typora 设置中开启 调试模式 后即可在正常视图右击打开 检查元素, 在其中就可以完全将 Markdown 文件当成 HTML 来编辑.💯 总结至此, Markdown + Typora / VSCode 的手册教程也告一段落.不知你看完这么长的教程/手册, 是否能体会到 Markdown 的精妙简洁之处呢?其实 Markdown 只是标记语言的最开始, 我的感受是会了 Markdown 之后对于理解 HTML 也有帮助, 对于用 $\\LaTeX$ 来写论文也有帮助. 标记语言正是为了摆脱 Word 那种虽然”所见即所得”, 但又过于花哨浮华, 很差的兼容性与闭源的编码的缺陷. 当你能掌握这样的”所写即所得”时, 你肯定会感受到用 Markdown 这类语言来处理文本的妙处! 沃兹·基·硕德 改编自「公鸡」普契涅拉. &#8617; " }, { "title": "Leetcode笔记（一)", "url": "/posts/Leetcode1/", "categories": "Leetcode", "tags": "leetcode", "date": "2022-08-25 18:30:00 +0000", "snippet": "测试一下上传图片路径可以放出来么！Github 开源项目搜索：Git开源项目搜索" } ]
