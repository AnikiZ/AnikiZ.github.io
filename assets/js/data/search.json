[ { "title": "Distributed Systems Notes", "url": "/posts/LearnDistributedSystems/", "categories": "Courses, Distributed System", "tags": "Go Instant messaging System Programming", "date": "2022-10-09 22:28:00 +0000", "snippet": "1. RPC and Multi-Threadsreason for multi-threads: I/O concurrency Parallelism(multiple cores, true parallelism, multiple cpu cycles per second) Convenience(fire something every some seconds in loop waiting for separate work; notice to exit every routine gracefully! otherwise accumulating in background!)what if not use multi-threads while still enabling multiple servers to communicate with various clients?Async programming/Event-Driven programmingsingle thread, single loop waiting for any input/event/timer fireinteresting: use multiple cores, each responsible for an event-driven loop, can also act like multi-threadsprocess vs threadProcess: a single programming you are running. In a go program, it will create one UNIX process and one memory area. When you create many go routines, these threads will run sitting in this process within same memory space.Example: URL crawler// should have a record of the URLs, otherwise keep crawling because pages in URL is cyclic// Serial Crawlerfunc Serial(url string, fetcher Fetcher, fetched map[string]bool) { // use a pointer of the map, not copy to prevent duplicated search if fetched[url] { return } fetched[url] = true urls, err := fetcher.Fetch(url) if err != nil { return } for _, u := range urls { Serial(u, fetcher, fetched) // what if change to go Serial(u, fetcher, fetched)? // only print one page because the main function will return, not waiting } return}// concurrent crawler with shared state and Mutextype fetchState struct { mu sync.Mutex fetched map[string]bool}func ConcurrentMutex(url string, fetcher Fetcher, f *fetchState) { f.mu.Lock() already := f.fetched[url] f.fetched[url] = true f.mu.Unlock() if already { return } urls, err := fetcher.Fetch(url) if err != nil { return } var done sync.WaitGroup for _, u := range urls { // done.Add(1) done.Add(1) go func(url string) { ConcurrentMutex(u, fetcher, f) defer done.Done() // decrement the done counter // use defer to call done no matter whether ConcurrentMutex will be executed successfully }(u) // here, the string parameter is a value copy of the outer u, not pointer // because string is immutable. Otherwise, the u will change in the outer for loop, and will change the u in the inner function! } done.Wait() // wait the counter to down to zero return}Q: If the surrounding function returns, what will happen to the inner functionâ€™s reference to variables in surrounding function?In go, the compiler will analyze the inner function(also called closured function) and allocate a heap memory for the variable. So the inner function can still get it and the gabbage collecter is responsible for noticing the last function to refer the little piece of heap and when it returns and releases then.Q: race detector in goIt allocates sort of shadow memory, (huge memory) almost for every memory location and keeps track of which thread read/write the memory location. And keep tracking of requiring/releasing locks and doing other synchronization activities/forcing other threads to not run concurrently. If it detects one of the location is written while another thread is reading the memory without a lock notation, it will release error. (Not static analyzing, but watching what happens in a particular part of the program. If this part didnâ€™t execute some code, like reading or writing a shared data, the race detector will never know whether there could be a race. So we need to set up some sort of a testing apparatus to make sure all the codes can be executed.) Actually the detector didnâ€™t see the interleaving/simultaneous execution, it just use the shadow memory to detect possible simultaneous read/write race without lock.Q: How many threads?In practical, there will be billions of urls, and to create billions of threads(too many memory, not feasible). Solution: pre-create a fixed size of pools of workers and have workers iteratively crawl.Use channel for concurrent crawling// no need to worry about shared memory by using channelfunc worker(url string, ch chan []string, fetcher Fetcher) { urls, err := fetcher.Fetch(url) if err != nil { ch &lt;- []string{} } else { ch &lt;- urls }}func master(ch chan []string, fetcher Fetcher) { // the master that use the channel n := 1 fetched := make(map[string]bool) // range: keep waiting until receive a new channel // if the channel is not closed, range will keep blocking // only condition to return is when n==0 for urls := range ch { for _, u := range urls { if fetched[u] == false { fetched[u] == true // n add 1 for each worker n+=1 go worker(u, ch, fetcher) } } n -= 1 // n=0, meaning no one is using the channel anymore if n == 0 { break } }}func ConcurrentChannel(url string, fetcher Fetcher) { ch := make(chan []string) go func() { ch &lt;- []string{url} }() master(ch, fetcher)}" }, { "title": "Distributed System__Instant messaging system mode", "url": "/posts/GoMessagingSystem/", "categories": "Courses, Distributed System", "tags": "Go Instant messaging System Programming", "date": "2022-09-12 19:39:00 +0000", "snippet": "Demo1: Instant messaging system - Serverreference1. Construct basic Serverserver.go, contains following; Server Struct, containing Ip, Port NewServer(ip String, port int) method to create server object (s *Server) Start() Start Server method (s *Server) Handler(conn net.Conn) handle connectionpackage mainimport ( \"fmt\" \"net\")type Server struct { Ip string Port int}// åˆ›å»ºä¸€ä¸ªserverçš„æ¥å£func NewServer(ip string, port int) *Server { server := &amp;Server{ Ip: ip, Port: port, } return server}func (s *Server) Handler(conn net.Conn) { // å½“å‰è¿æ¥çš„ä¸šåŠ¡ fmt.Println(\"Connected Successfully!\")}// å¯åŠ¨æœåŠ¡å™¨çš„æ¥å£func (s *Server) Start() { // socket listen listener, err := net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", s.Ip, s.Port)) if err != nil { fmt.Println(\"net.Listen err: \", err) return } // close listen socket defer listener.Close() for { // accpet conn, err := listener.Accept() if err != nil { fmt.Println(\"listener accept err: \", err) continue } // do handler go s.Handler(conn) }}main.go , start the Server:package mainfunc main() { server := NewServer(\"127.0.0.1\", 8888) server.Start()}Linux or MacOS command:build these two file: go build -o server main.go server.gorun: ./serverlisten to the service: nc 127.0.0.1 88882. User online functionuser.go: NewUser(conn net.Conn) *User åˆ›å»ºä¸€ä¸ª user å¯¹è±¡ (u *User) ListenMessage() ç›‘å¬ user å¯¹åº”çš„ channel æ¶ˆæ¯```gotype User struct { Name string Addr string C chan string conn net.Conn}// åˆ›å»ºä¸€ä¸ªç”¨æˆ·çš„APIfunc NewUser(conn net.Conn) *User { // from server accept, remote address is userâ€™s address itself userAddr := conn.RemoteAddr().String()user := &amp;User{ Name: userAddr, Addr: userAddr, C: make(chan string), conn: conn,}// å¯åŠ¨ç›‘å¬å½“å‰user channelæ¶ˆæ¯çš„goroutinego user.ListenMessage()return user }// ç›‘å¬å½“å‰user channelçš„æ–¹æ³•ï¼Œä¸€æ—¦æœ‰æ¶ˆæ¯ï¼Œç›´æ¥å‘é€ç»™å®¢æˆ·ç«¯func (u *User) ListenMessage() { for { msg := &lt;-u.C u.conn.Write([]byte(msg + â€œ\\nâ€)) }}server.go:- Add OnlineMap and Message fields- Create and add new user when handling client connection- Add listen and broadcast channel method- use a goroutine to listen Message```go/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-06 03:00:10 * @LastEditTime: 2022-09-11 23:03:11 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /learnGo/14_golang_IM_System/server.go */package mainimport (\t\"fmt\"\t\"net\"\t\"sync\")type Server struct {\tIp string\tPort int\t// online user's map\tOnlineMap map[string]*User\tmapLock sync.RWMutex\t// broadcast channel\tMessage chan string}// A server objectfunc NewServer(ip string, port int) *Server {\t// var server *Server\tserver := &amp;Server{\t\tIp: ip,\t\tPort: port,\t\tOnlineMap: make(map[string]*User),\t\tMessage: make(chan string),\t}\treturn server}// goroutine to listen the message channel to send to all online userfunc (s *Server) ListenMessage() {\tfor {\t\tmsg := &lt;-s.Message\t\t// send msg to all online user\t\ts.mapLock.Lock()\t\tfor _, cli := range s.OnlineMap {\t\t\tcli.C &lt;- msg\t\t}\t\ts.mapLock.Unlock()\t}}// method to broadcast msgsfunc (s *Server) Broadcast(user *User, msg string) {\tsendMsg := \"[\" + user.Addr + \"]\" + user.Name + \":\" + msg\ts.Message &lt;- sendMsg}func (s *Server) Handler(conn net.Conn) {\t// ... current connect business\tfmt.Println(\"Connect successfully!\")\tuser := NewUser(conn)\t// user online, add user to onlineMap\ts.mapLock.Lock()\ts.OnlineMap[user.Name] = user\ts.mapLock.Unlock()\t// broadcast current user's online msg\ts.Broadcast(user, \"Online!\")\t// handler block\tselect {}}func (s *Server) Start() {\t// socket listen\tListener, err := net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", s.Ip, s.Port))\tif err != nil {\t\tfmt.Println(\"net.Listen err:\", err)\t\treturn\t}\t// close listen socket\tdefer Listener.Close()\t// Start listen Message goroutine\tgo s.ListenMessage()\tfor {\t\t// accept\t\tconn, err := Listener.Accept()\t\tif err != nil {\t\t\tfmt.Println(\"net.Listen err:\", err)\t\t\tcontinue\t\t}\t\t// dp handler\t\tgo s.Handler(conn)\t}}ç»“æ„ä½“ä¸­çš„channelåŸºæœ¬éƒ½éœ€è¦å¼€ä¸€ä¸ªå¾ªç¯å»ç›‘å¬å…¶å˜åŒ–ï¼ˆå°è¯•å–å‡ºå€¼ï¼Œå‘é€ç»™å…¶ä»–channelï¼‰3. Broadcast clientsâ€™ messagesserver.go: Improve the handle processing business method and start a read routine for the current client/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-06 03:00:10 * @LastEditTime: 2022-09-11 23:18:59 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /learnGo/14_golang_IM_System/server.go */package mainimport (\t\"fmt\"\t\"io\"\t\"net\"\t\"sync\")type Server struct {\tIp string\tPort int\t// online user's map\tOnlineMap map[string]*User\tmapLock sync.RWMutex\t// broadcast channel\tMessage chan string}// A server objectfunc NewServer(ip string, port int) *Server {\t// var server *Server\tserver := &amp;Server{\t\tIp: ip,\t\tPort: port,\t\tOnlineMap: make(map[string]*User),\t\tMessage: make(chan string),\t}\treturn server}// goroutine to listen the message channel to send to all online userfunc (s *Server) ListenMessage() {\tfor {\t\tmsg := &lt;-s.Message\t\t// send msg to all online user\t\ts.mapLock.Lock()\t\tfor _, cli := range s.OnlineMap {\t\t\tcli.C &lt;- msg\t\t}\t\ts.mapLock.Unlock()\t}}// method to broadcast msgsfunc (s *Server) Broadcast(user *User, msg string) {\tsendMsg := \"[\" + user.Addr + \"]\" + user.Name + \":\" + msg\ts.Message &lt;- sendMsg}func (s *Server) Handler(conn net.Conn) {\t// ... current connect business\tfmt.Println(\"Connect successfully!\")\tuser := NewUser(conn)\t// user online, add user to onlineMap\ts.mapLock.Lock()\ts.OnlineMap[user.Name] = user\ts.mapLock.Unlock()\t// broadcast current user's online msg\ts.Broadcast(user, \"Online!\")\t// Receiver users' msgs\tgo func() {\t\tbuf := make([]byte, 4096)\t\tfor {\t\t\tn, err := conn.Read(buf)\t\t\tif n == 0 {\t\t\t\ts.Broadcast(user, \"Offline\")\t\t\t\t// ctrl + c: will kill the user pid, and broadcast offline to other users\t\t\t\t// return to end the routine, every user has one!\t\t\t\treturn\t\t\t}\t\t\tif err != nil &amp;&amp; err != io.EOF {\t\t\t\tfmt.Println(\"Conn Read err:\", err)\t\t\t\treturn\t\t\t}\t\t\t// extract msg (delete '\\n' in the end)\t\t\tmsg := string(buf[:n-1])\t\t\t// broadcast msg\t\t\ts.Broadcast(user, msg)\t\t}\t}()\t// handler block\tselect {}}func (s *Server) Start() {\t// socket listen\tListener, err := net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", s.Ip, s.Port))\tif err != nil {\t\tfmt.Println(\"net.Listen err:\", err)\t\treturn\t}\t// close listen socket\tdefer Listener.Close()\t// Start listen Message goroutine\tgo s.ListenMessage()\tfor {\t\t// accept\t\tconn, err := Listener.Accept()\t\tif err != nil {\t\t\tfmt.Println(\"net.Listen err:\", err)\t\t\tcontinue\t\t}\t\t// dp handler\t\tgo s.Handler(conn)\t}}4. Encapsulate user APIuser.go: Add server field in user struct Add Online, Offline, DoMessage methods/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-11 22:47:44 * @LastEditTime: 2022-09-11 23:35:04 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /learnGo/14_golang_IM_System/User.go */package mainimport \"net\"type User struct {\tName string\tAddr string\tC chan string\tconn net.Conn\tserver *Server}// åˆ›å»ºä¸€ä¸ªç”¨æˆ·çš„APIfunc NewUser(conn net.Conn, server *Server) *User {\tuserAddr := conn.RemoteAddr().String()\tuser := &amp;User{\t\tName: userAddr,\t\tAddr: userAddr,\t\tC: make(chan string),\t\tconn: conn,\t\tserver: server,\t}\t// å¯åŠ¨ç›‘å¬å½“å‰user channelæ¶ˆæ¯çš„goroutine\tgo user.ListenMessage()\treturn user}// user onlinefunc (u *User) Online() {\t// user online, add user to onlineMap\tu.server.mapLock.Lock()\tu.server.OnlineMap[u.Name] = u\tu.server.mapLock.Unlock()\t// broadcast online msg\tu.server.Broadcast(u, \"Online!\")}// user offlinefunc (u *User) Offline() {\t// user offline, delete it from onlineMap\tu.server.mapLock.Lock()\tdelete(u.server.OnlineMap, u.Name)\tu.server.mapLock.Unlock()\t// broadcast offline msg\tu.server.Broadcast(u, \"Offline!\")}// handle user msgfunc (u *User) DoMessage(msg string) {\tu.server.Broadcast(u, msg)}// ç›‘å¬å½“å‰user channelçš„æ–¹æ³•ï¼Œä¸€æ—¦æœ‰æ¶ˆæ¯ï¼Œç›´æ¥å‘é€ç»™å®¢æˆ·ç«¯func (u *User) ListenMessage() {\tfor {\t\tmsg := &lt;-u.C\t\tu.conn.Write([]byte(msg + \"\\n\"))\t}}server.go: Use user API to replace code before/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-06 03:00:10 * @LastEditTime: 2022-09-11 23:36:35 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /learnGo/14_golang_IM_System/server.go */package mainimport (\t\"fmt\"\t\"io\"\t\"net\"\t\"sync\")type Server struct {\tIp string\tPort int\t// online user's map\tOnlineMap map[string]*User\tmapLock sync.RWMutex\t// broadcast channel\tMessage chan string}// A server objectfunc NewServer(ip string, port int) *Server {\t// var server *Server\tserver := &amp;Server{\t\tIp: ip,\t\tPort: port,\t\tOnlineMap: make(map[string]*User),\t\tMessage: make(chan string),\t}\treturn server}// goroutine to listen the message channel to send to all online userfunc (s *Server) ListenMessage() {\tfor {\t\tmsg := &lt;-s.Message\t\t// send msg to all online user\t\ts.mapLock.Lock()\t\tfor _, cli := range s.OnlineMap {\t\t\tcli.C &lt;- msg\t\t}\t\ts.mapLock.Unlock()\t}}// method to broadcast msgsfunc (s *Server) Broadcast(user *User, msg string) {\tsendMsg := \"[\" + user.Addr + \"]\" + user.Name + \":\" + msg\ts.Message &lt;- sendMsg}func (s *Server) Handler(conn net.Conn) {\t// ... current connect business\tfmt.Println(\"Connect successfully!\")\tuser := NewUser(conn, s)\t// user online, add user to onlineMap\tuser.Online()\t// broadcast current user's online msg\ts.Broadcast(user, \"Online!\")\t// Receiver users' msgs\tgo func() {\t\tbuf := make([]byte, 4096)\t\tfor {\t\t\tn, err := conn.Read(buf)\t\t\tif n == 0 {\t\t\t\tuser.Offline()\t\t\t\t// ctrl + c: will kill the user pid, and broadcast offline to other users\t\t\t\t// return to end the routine, every user has one!\t\t\t\treturn\t\t\t}\t\t\tif err != nil &amp;&amp; err != io.EOF {\t\t\t\tfmt.Println(\"Conn Read err:\", err)\t\t\t\treturn\t\t\t}\t\t\t// extract msg (delete '\\n' in the end)\t\t\tmsg := string(buf[:n-1])\t\t\t// broadcast msg\t\t\tuser.DoMessage(msg)\t\t}\t}()\t// handler block\tselect {}}func (s *Server) Start() {\t// socket listen\tListener, err := net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", s.Ip, s.Port))\tif err != nil {\t\tfmt.Println(\"net.Listen err:\", err)\t\treturn\t}\t// close listen socket\tdefer Listener.Close()\t// Start listen Message goroutine\tgo s.ListenMessage()\tfor {\t\t// accept\t\tconn, err := Listener.Accept()\t\tif err != nil {\t\t\tfmt.Println(\"net.Listen err:\", err)\t\t\tcontinue\t\t}\t\t// dp handler\t\tgo s.Handler(conn)\t}}5. Search online users and rename userName5.1 Search online usersif user inputs â€˜whoâ€™, then return online users to himuser.go: Add send message API func (u *User) SendMsg(msg string) { u.conn.Write([]byte(msg))} In DoMessage() method, add function to handle â€œwhoâ€ msg, output online usersâ€™ info func (u *User) DoMessage(msg string) { if msg == \"who\" { // look for current online users u.server.mapLock.Lock() for _, user := range u.server.OnlineMap { onlineMsg := \"[\" + user.Addr + \"]\" + user.Name + \":\" + \"Online...\\n\" u.SendMsg(onlineMsg) } u.server.mapLock.Unlock() } else { u.server.Broadcast(u, msg) }} 5.2 Rename userName if a user inputs â€œrename|zzpâ€, it will change his name to â€œzzpâ€user.go: In DoMessage() method, add case for handling â€œrename|xxxâ€ func (u *User) DoMessage(msg string) { if msg == \"who\" { // look for current online users u.server.mapLock.Lock() for _, user := range u.server.OnlineMap { onlineMsg := \"[\" + user.Addr + \"]\" + user.Name + \":\" + \"Online...\\n\" u.SendMsg(onlineMsg) } u.server.mapLock.Unlock() } else if len(msg) &gt; 7 &amp;&amp; msg[:7] == \"rename|\" { // format:\"rename|xxx\" newName := strings.Split(msg, \"|\")[1] // check if newName has existed _, ok := u.server.OnlineMap[newName] if ok { u.SendMsg(\"This userName has been used!\\n\") } else { u.server.mapLock.Lock() delete(u.server.OnlineMap, newName) u.server.OnlineMap[newName] = u u.server.mapLock.Unlock() u.Name = newName u.SendMsg(\"You have updated the userName: \" + u.Name + \"\\n\") } } else { u.server.Broadcast(u, msg) }} 6. Close the user when exceeds time limitWhen a user hasnâ€™t sent a msg for a long time, he will be kicked.server.go: In handler() goroutine, add islive channel, if the user send a message, add true func (s *Server) Handler(conn net.Conn) { // ... current connect business fmt.Println(\"Connect successfully!\") user := NewUser(conn, s) // user online, add user to onlineMap user.Online() //check whether user is alive islive := make(chan bool) // Receiver users' msgs go func() { buf := make([]byte, 4096) for { n, err := conn.Read(buf) if n == 0 { user.Offline() // ctrl + c: will kill the user pid, and broadcast offline to other users // return to end the routine, every user has one! return } if err != nil &amp;&amp; err != io.EOF { fmt.Println(\"Conn Read err:\", err) return } // extract msg (delete '\\n' in the end) msg := string(buf[:n-1]) // broadcast msg user.DoMessage(msg) islive &lt;- true } }() for { // selectç†è§£ï¼š é¦–å…ˆæ‰§è¡Œcaseå³è¾¹è¯­å¥å¹¶è¯„ä¼°ï¼Œéƒ½æ²¡æœ‰å¯è¡Œçš„å°±ä¼šé˜»å¡ï¼Œè¶…è¿‡ä¸€ä¸ªå¯è¡Œä¼šéšæœºé€‰ä¸­case // ç„¶åè¿›å…¥ä¸‹ä¸€æ¬¡è½®è¯¢ï¼Œæ¯æ¬¡è½®è¯¢éƒ½ä¼šé‡æ–°æ‰§è¡Œæ‰€æœ‰caseå³è¾¹è¯­å¥å¹¶å¼€å§‹è¯„ä¼°ï¼ // å‚è€ƒï¼šhttps://www.cnblogs.com/f-ck-need-u/p/9994512.html select { // if islive, do nothing, and select will enter into next check, // also the time counting will be reset. // æŠŠtime.After() å†™åœ¨é‡Œé¢çš„è¯ï¼Œå¦‚æœislive caseé€‰ä¸­ï¼Œä¸‹ä¸€æ¬¡è½®è¯¢å°±ä¼šé‡ç½®è®¡æ—¶ case &lt;-islive: // current user is alive, do nothing and reset time in next check case &lt;-time.After(time.Second * 10): // time exceeds! kick the user user.SendMsg(\"You are kicked!\\n\") // close resources close(user.C) conn.Close() // exit return } } // handler block select {}} 7. Private communication modemsg format: to|name|contentwill send message to a specific userfunc (u *User) DoMessage(msg string) {\tif msg == \"who\" {\t\t// look for current online users\t\tu.server.mapLock.Lock()\t\tfor _, user := range u.server.OnlineMap {\t\t\tonlineMsg := \"[\" + user.Addr + \"]\" + user.Name + \":\" + \"Online...\\n\"\t\t\tu.SendMsg(onlineMsg)\t\t}\t\tu.server.mapLock.Unlock()\t} else if len(msg) &gt; 7 &amp;&amp; msg[:7] == \"rename|\" {\t\t// format:\"rename|xxx\"\t\tnewName := strings.Split(msg, \"|\")[1]\t\t// check if newName has existed\t\t_, ok := u.server.OnlineMap[newName]\t\tif ok {\t\t\tu.SendMsg(\"This userName has been used!\\n\")\t\t} else {\t\t\tu.server.mapLock.Lock()\t\t\tdelete(u.server.OnlineMap, newName)\t\t\tu.server.OnlineMap[newName] = u\t\t\tu.server.mapLock.Unlock()\t\t\tu.Name = newName\t\t\tu.SendMsg(\"You have updated the userName: \" + u.Name + \"\\n\")\t\t}\t} else if len(msg) &gt; 4 &amp;&amp; msg[:3] == \"to|\" {\t\t// msg format: to|zzp|content\t\t// 1. get receiver's username\t\tremoteName := strings.Split(msg, \"|\")[1]\t\tif remoteName == \"\" {\t\t\tu.SendMsg(\"Please give a valid name! format is to|name|content\\n\")\t\t\treturn\t\t}\t\t// 2. According to the username, get the user object\t\tremoteUser, ok := u.server.OnlineMap[remoteName]\t\tif !ok {\t\t\tu.SendMsg(\"This user doesn't exist!\\n\")\t\t\treturn\t\t}\t\t// 3. remoteUser exists, send msg to remoteUser\t\tcontent := strings.Split(msg, \"|\")[2]\t\tif content == \"\" {\t\t\tu.SendMsg(\"Content is not valid\\n\")\t\t\treturn\t\t} else {\t\t\tremoteUser.SendMsg(u.Name + \" says:\" + content)\t\t}\t} else {\t\tu.server.Broadcast(u, msg)\t}}Demo2: Instant messaging system - ClientDefine client struct and connectionclient.go:/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-13 00:05:29 * @LastEditTime: 2022-09-13 00:12:57 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /learnGo/14_golang_IM_System/client.go */package mainimport (\t\"fmt\"\t\"net\")type Client struct {\tServerIp string\tServerPort int\tName string\tconn net.Conn}func NewClient(serverIp string, serverPort int) *Client {\t// create a new client object\tclient := &amp;Client{\t\tServerIp: serverIp,\t\tServerPort: serverPort,\t}\t// connect to server\tconn, err := net.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", serverIp, serverPort))\tif err != nil {\t\tfmt.Println(\"net.Dial error: \", err)\t\treturn nil\t}\tclient.conn = conn\t// return object\tfmt.Println(\"Connect successfully! localaddr:\")\tfmt.Println(conn.LocalAddr())\tfmt.Println(\"Connect successfully! Remoteaddr:\")\tfmt.Println(conn.RemoteAddr())\treturn client}func main() {\tclient := NewClient(\"127.0.0.1\", 8888)\tif client == nil {\t\tfmt.Println(\"&gt;&gt;&gt; connect fail!\")\t\treturn\t}\tfmt.Println(\"&gt;&gt;&gt; Connect succeeds!\")\tselect {}}go build -o client client.gorun: ./clientParse command lineInitialize command line args and parse them in init functionvar serverIp stringvar serverPort intfunc init() {\tflag.StringVar(&amp;serverIp, \"ip\", \"127.0.0.1\", \"Set server ip addr(default: 127.0.0.1)\")\tflag.IntVar(&amp;serverPort, \"port\", 8888, \"Set server port(default: 8888)\")\t// parse command line\tflag.Parse()}in main function:client := NewClient(serverIp, serverPort)Can parse args in command line to run client./client -h : get help./client -ip 127.0.0.1 -port 8888Menu displayadd new flag field in client struct:type Client struct {\tServerIp string\tServerPort int\tName string\tconn net.Conn\tflag int // current client mode}add menu function to get inputfunc (client *Client) menu() bool {\tvar flag int\tfmt.Println(\"1. Public messaging mode\")\tfmt.Println(\"2. Private messaging mode\")\tfmt.Println(\"3. Update userName\")\tfmt.Println(\"0. Exit\")\tfmt.Scanln(&amp;flag)\tif flag &gt;= 0 &amp;&amp; flag &lt;= 3 {\t\tclient.flag = flag\t\treturn true\t} else {\t\tfmt.Println(\"&gt;&gt;&gt; Please enter valid number (0 ~ 3)\")\t\treturn false\t}}add run() to loop main business:func (client *Client) Run() {\tfor client.flag != 0 {\t\tfor !client.menu() {\t\t}\t\t// Handle different business\t\tswitch client.flag {\t\tcase 1:\t\t\t// Public\t\t\tfmt.Println(\"Public\")\t\t\tbreak\t\tcase 2:\t\t\t// Private\t\t\tfmt.Println(\"Private\")\t\tcase 3:\t\t\t// Update user name\t\t\tfmt.Println(\"Update user name\")\t\t}\t}\tfmt.Println(\"Exit!\")}add flag in new client function:func NewClient(serverIp string, serverPort int) *Client {\t// create a new client object\tclient := &amp;Client{\t\tServerIp: serverIp,\t\tServerPort: serverPort,\t\tflag: 999, // if 0, will exit directly!\t}\t// connect to server\tconn, err := net.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", serverIp, serverPort))\tif err != nil {\t\tfmt.Println(\"net.Dial error: \", err)\t\treturn nil\t}\tclient.conn = conn\t// return object\tfmt.Println(\"Connect successfully! localaddr:\")\tfmt.Println(conn.LocalAddr())\tfmt.Println(\"Connect successfully! Remoteaddr:\")\tfmt.Println(conn.RemoteAddr())\treturn client}Update user nameAdd UpdateName() function to update user name:func (client *Client) UpdateName() bool {\tfmt.Println(\"&gt;&gt;&gt;Please input username: \")\tfmt.Scanln(&amp;client.Name)\tsendMsg := \"rename|\" + client.Name + \"\\n\" // encapsulate protocal\t_, err := client.conn.Write([]byte(sendMsg)) // server will read the msg and handle it\tif err != nil {\t\tfmt.Println(\"conn.Write err: \", err)\t\treturn false\t}\treturn true}Add DealResponse() method to handle serverâ€™s response msgReason: the run() method will always block for input, need another goroutine to handle serverâ€™s responsefunc (client *Client) DealResponse() {\tio.Copy(os.Stdout, client.conn)\t// be like following: Once client.conn has data can read, copy to stdout, always block and listen!\t// for {\t// \tbuf := make()\t// \tclient.conn.Read(buf)\t// \tfmt.Println(\"\")\t// }}Open a goroutine in main, to deal with response!func main() {\tclient := NewClient(serverIp, serverPort)\tif client == nil {\t\tfmt.Println(\"&gt;&gt;&gt; connect fail!\")\t\treturn\t}\t// open a goroutine to handle server's feedback msg\tgo client.DealResponse()\tfmt.Println(\"&gt;&gt;&gt; Connect succeeds!\")\tclient.Run()\tselect {}}Public messaging modeAdd PublicChat():func (client *Client) PublicChat() {\t// user input msg\tvar chatMsg string\tfmt.Println(\"&gt;&gt;&gt; Please enter msg, input exit to exit\")\tfmt.Scanln(&amp;chatMsg)\tfor chatMsg != \"exit\" {\t\t// send to server\t\t// msg != null, send at once\t\tif len(chatMsg) != 0 {\t\t\tsendMsg := chatMsg + \"\\n\"\t\t\t_, err := client.conn.Write([]byte(sendMsg))\t\t\tif err != nil {\t\t\t\tfmt.Println(\"conn Write err: \", err)\t\t\t\tbreak\t\t\t}\t\t}\t\tchatMsg = \"\"\t\tfmt.Println(\"&gt;&gt;&gt; Please enter msg, input exit to exit\")\t\tfmt.Scanln(&amp;chatMsg)\t}}Private chatting modeSearch online clients:func (client *Client) SelectUsers() {\tsendMsg := \"who\\n\"\t_, err := client.conn.Write([]byte(sendMsg))\tif err != nil {\t\tfmt.Println(\"conn Write err: \", err)\t\treturn\t}}Add private mode:func (client *Client) PrivateChat() {\tvar remoteName string\tvar chatMsg string\tclient.SelectUsers()\tfmt.Println(\"&gt;&gt;&gt;&gt;è¯·è¾“å…¥èŠå¤©å¯¹è±¡çš„[ç”¨æˆ·å], exité€€å‡º: \")\tfmt.Scanln(&amp;remoteName)\tfor remoteName != \"exit\" {\t\tfmt.Println(\"&gt;&gt;&gt;&gt;è¯·è¾“å…¥æ¶ˆæ¯å†…å®¹ï¼Œexité€€å‡º:\")\t\tfmt.Scanln(&amp;chatMsg)\t\tfor chatMsg != \"exit\" {\t\t\t// æ¶ˆæ¯ä¸ä¸ºç©ºåˆ™å‘é€\t\t\tif len(chatMsg) != 0 {\t\t\t\tsendMsg := \"to|\" + remoteName + \"|\" + chatMsg + \"\\n\\n\"\t\t\t\t_, err := client.conn.Write([]byte(sendMsg))\t\t\t\tif err != nil {\t\t\t\t\tfmt.Println(\"conn Write err: \", err)\t\t\t\t\tbreak\t\t\t\t}\t\t\t}\t\t\tchatMsg = \"\"\t\t\tfmt.Println(\"&gt;&gt;&gt;&gt;è¯·è¾“å…¥æ¶ˆæ¯å†…å®¹ï¼Œexité€€å‡º:\")\t\t\tfmt.Scanln(&amp;chatMsg)\t\t}\t\tclient.SelectUsers()\t\tfmt.Println(\"&gt;&gt;&gt;&gt;è¯·è¾“å…¥èŠå¤©å¯¹è±¡çš„[ç”¨æˆ·å], exité€€å‡º: \")\t\tfmt.Scanln(&amp;remoteName)\t}}" }, { "title": "Distributed System__Java Web Programming Practice", "url": "/posts/JavaWeb/", "categories": "Courses, Distributed System", "tags": "Java Web Programming", "date": "2022-09-11 03:39:00 +0000", "snippet": "Port(PID)netstat -ano #æŸ¥çœ‹æ‰€æœ‰ç«¯å£netstat -ano|findstr \"6732\" #æŸ¥çœ‹æŒ‡å®šç«¯å£tasklist|findstr \"6732\" #æŸ¥çœ‹æŒ‡å®šè¿›ç¨‹# ä½¿ç”¨ä»»åŠ¡ç®¡ç†å™¨æŸ¥çœ‹PIDç«¯å£å·ä¸IPåœ°å€çš„ç»„åˆï¼Œå¾—å‡ºä¸€ä¸ªç½‘ç»œå¥—æ¥å­—:Socketï¼Œæ‰€ä»¥è¯´ä¸€äº›ç½‘ç»œç¼–ç¨‹ä¹Ÿè¢«ç§°ä¸ºSocketç¼–ç¨‹import java.net.InetSocketAddress;public class InetSocketAddressTest { public static void main(String[] args) { InetSocketAddress socketAddress = new InetSocketAddress(\"127.0.0.1\",8080); InetSocketAddress socketAddress2 = new InetSocketAddress(\"localhost\",9000); System.out.println(socketAddress.getHostName()); System.out.println(socketAddress.getAddress()); System.out.println(socketAddress.getPort()); System.out.println(socketAddress2.getHostName()); System.out.println(socketAddress2.getAddress()); //è¿”å›åœ°å€ System.out.println(socketAddress2.getPort()); //è¿”å›ç«¯å£ } }Protocal1. TCP Demo1.1 Client Demo1import java.io.IOException;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;import java.net.UnknownHostException;//å®¢æˆ·ç«¯public class TcpClientDemo01 { public static void main(String[] args) { Socket socket = null; OutputStream os = null; try { //1. è¿æ¥æœåŠ¡å™¨çš„åœ°å€ InetAddress serverIP = InetAddress.getByName(\"127.0.0.1\"); int port = 8899; //2. åˆ›å»ºä¸€ä¸ªSocket socket = new Socket(serverIP,port); //3. åˆ›å»ºä¸€ä¸ªè¾“å‡ºæµï¼Œå‘å¤–å†™ä¸œè¥¿ os = socket.getOutputStream(); os.write(\"ä½ å¥½,æ¬¢è¿å­¦ä¹ ç‹‚ç¥è¯´Java\".getBytes()); } catch (UnknownHostException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { //4. å…³é—­èµ„æº try { if (os!=null){ os.close(); } if (socket!=null){ socket.close(); } } catch (IOException e) { e.printStackTrace(); } } }}1.2. Server Demo1import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;//æœåŠ¡ç«¯public class TcpServerDemo01 { public static void main(String[] args) { ServerSocket serverSocket = null; Socket accept = null; InputStream is = null; ByteArrayOutputStream baos = null; try { //1. å¼€æ”¾æœåŠ¡å™¨ç«¯å£ï¼Œåˆ›å»ºServerSocket serverSocket = new ServerSocket(8899); while (true) { //2. ç­‰å¾…å®¢æˆ·ç«¯çš„è¿æ¥ accept = serverSocket.accept(); //3. è¯»å…¥å®¢æˆ·ç«¯çš„æ¶ˆæ¯, is = accept.getInputStream(); /* å›å¿†ä¹‹å‰çš„IOæµæ–¹æ¡ˆï¼Œå¼Šç«¯:å­˜åœ¨ä¸­æ–‡ï¼Œå¯èƒ½å­˜åœ¨ä¹±ç ã€‚ byte[] buffer = new byte[1024]; int len; while ((len=is.read(buffer))!=-1){ String str = new String(buffer,0,len); System.out.println(str); } **/ baos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len; while ((len=is.read(buffer))!=-1){ baos.write(buffer,0,len); } System.out.println(baos.toString()); System.out.println(\"æ•°æ®æ¥æºåœ°å€:\"+accept.getInetAddress().getHostName()); } } catch (IOException e) { e.printStackTrace(); } finally { //4. å…³é—­èµ„æº try { if (baos!=null){ baos.close(); } if (is!=null){ is.close(); } if (accept!=null){ accept.close(); } if (serverSocket!=null){ serverSocket.close(); } }catch (Exception e) { e.printStackTrace(); } } }}1.3 Client Demo2/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-10 15:33:20 * @LastEditTime: 2022-09-11 02:43:36 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /JavaWebPractice/TcpClientDemo02.java */import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.InputStream;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;public class TcpClientDemo02 { public static void main(String[] args) throws Exception { // 1. åˆ›å»ºserverè¿æ¥ Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"), 9090); // 2. åˆ›å»ºä¸€ä¸ªè¾“å‡ºæµ OutputStream os = socket.getOutputStream(); // 3. è¯»å–æ–‡ä»¶ FileInputStream fis = new FileInputStream(new File(\"textfile.txt\")); // 4. å†™å‡ºæ–‡ä»¶ byte[] buffer = new byte[1024]; int len; // file has EOF, so fis.read() will not block while ((len = fis.read(buffer)) != -1) { os.write(buffer, 0, len); } // tell server the output stream is over and close output, // otherwise server will always be waiting socket.shutdownOutput(); // wait for server to reply, and respond to console // System.out.println(\"I can get there!\"); InputStream inputStream = socket.getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer2 = new byte[1024]; int len2; // Why server doesn't shut down its outputStream but this won't get blocked? // because the server will end its function and close, then the inputStream will not block while ((len2 = inputStream.read(buffer2)) != -1) { baos.write(buffer2, 0, len2); // System.out.println(\"I can get there!\"); } System.out.println(\"I can get there!\"); System.out.println(baos.toString()); // 5. èµ„æºå…³é—­ï¼Œåº”è¯¥ä½¿ç”¨try-catch-finally baos.close(); inputStream.close(); fis.close(); os.close(); socket.close(); }}1.4 Server Demo2/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-10 15:33:28 * @LastEditTime: 2022-09-11 02:40:41 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /JavaWebPractice/TcpServerDemo02.java */import java.io.File;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;import java.util.concurrent.TimeUnit;public class TcpServerDemo02 { public static void main(String[] args) throws Exception{ // 1. open serverSocket ServerSocket serverSocket = new ServerSocket(9090); // 2. listen client socket Socket socket = serverSocket.accept(); // 3. get inputStream InputStream is = socket.getInputStream(); // 4. read file and writer to a new file FileOutputStream fos = new FileOutputStream(new File(\"receive.txt\")); byte[] buffer = new byte[1024]; int len; // inputStream read is block function, unless outputStream shut down or closed, will always blocked, // not even get into the while loop once. while ((len = is.read(buffer)) != -1) { // System.out.println(\"I can get there!\"); fos.write(buffer, 0, len); } System.out.println(\"I can get there!\"); // tell client receive successfully OutputStream outputStream = socket.getOutputStream(); outputStream.write(\"File has been received successfully!\".getBytes()); TimeUnit.SECONDS.sleep(1); outputStream.write(\"Can you receive this?\".getBytes()); // 5. close, should use try-catch-finally outputStream.close(); fos.close(); is.close(); socket.close(); serverSocket.close(); }}2. UDP Demo2.1 è¯´æ˜ DatagramSocket å’Œ DatagramPacket ä¸¤ä¸ªç±»å®ç°äº†åŸºäºUDPåè®®çš„ç½‘ç»œç¨‹åºã€‚ UDP æ•°æ®æŠ¥é€šè¿‡æ•°æ®æŠ¥å¥—æ¥å­— DatagramSocket å‘é€å’Œæ¥æ”¶ï¼Œç³»ç»Ÿä¸ä¿è¯UDPæ•°æ®æŠ¥ä¸€å®šèƒ½å¤Ÿå®‰ å…¨é€åˆ°ç›®çš„åœ°ï¼Œä¹Ÿä¸ç¡®å®šä»€ä¹ˆæ—¶å€™å¯ä»¥æŠµè¾¾ã€‚ DatagramPacket å¯¹è±¡å°è£…äº†UDPæ•°æ®æŠ¥ï¼Œåœ¨æ•°æ®æŠ¥ä¸­åŒ…å«äº†å‘é€ç«¯çš„IPåœ°å€å’Œç«¯å£å·ä»¥åŠæ¥æ”¶ç«¯ çš„IPåœ°å€å’Œç«¯å£å·ã€‚ UDPåè®®ä¸­æ¯ä¸ªæ•°æ®æŠ¥éƒ½ç»™å‡ºäº†å®Œæ•´çš„åœ°å€ä¿¡æ¯ï¼Œå› æ­¤æ— éœ€å»ºç«‹å‘é€æ–¹å’Œæ¥æ”¶æ–¹çš„è¿æ¥ã€‚å¦‚åŒå‘å¿«é€’åŒ…è£¹ä¸€æ ·ã€‚2.2 Demo1 TalkingSenderimport java.io.BufferedReader;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-10 17:01:23 * @LastEditTime: 2022-09-10 17:12:10 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /JavaWebPractice/UdpSenderDemo01.java */public class UdpSenderDemo01 { public static void main(String[] args) throws Exception{ System.out.println(\"Sender start...\"); // 1. create DatagramSocket DatagramSocket socket = new DatagramSocket(8888); // 2. encapsulate data packet // String msg = \"Udpsender==&gt;\"; // byte[] data = msg.getBytes(); // InetAddress inet = InetAddress.getByName(\"127.0.0.1\"); // int port = 9090; // // args: byte[], offset, length, socket(address, port) // DatagramPacket packet = new DatagramPacket(data, 0, data.length, inet, port); // 2. encapsulate data packet from console input BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); while (true) { String data = reader.readLine(); byte[] datas = data.getBytes(); // 3. encapsulate datas to DatagramPacket, send to destination DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(\"localhost\", 6666)); // 4. send packet to receiver socket.send(packet); // exit check if (data.equals(\"bye\")) { break; } } // 5. close reader.close(); socket.close(); }}Receiver/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-10 17:12:28 * @LastEditTime: 2022-09-10 17:18:21 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /JavaWebPractice/UdpReceiverDemo01.java */import java.net.DatagramPacket;import java.net.DatagramSocket;public class UdpReceiverDemo01 { public static void main(String[] args) throws Exception{ DatagramSocket socket= new DatagramSocket(6666); while(true) { try { byte[] container = new byte[1024]; DatagramPacket packet = new DatagramPacket(container, 0, container.length); socket.receive(packet); // receive packet(block) byte[] datas = packet.getData(); int len = packet.getLength(); String data = new String(datas, 0, len); System.out.println(data); // exit check if (data.equals(\"bye\")) { break; } } catch (Exception e) { e.printStackTrace(); } } socket.close(); }}2.3 Demo2 Multi-thread TalkingSenderThread/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-10 23:01:28 * @LastEditTime: 2022-09-10 23:09:24 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /JavaWebPractice/TalkSend.java */import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;public class TalkSend implements Runnable { private DatagramSocket socket; private BufferedReader reader; private String toIp; private int toPort; public TalkSend(int port, String toIp, int toPort) { this.toIp = toIp; this.toPort = toPort; try { socket = new DatagramSocket(port); reader =new BufferedReader(new InputStreamReader(System.in)); } catch (Exception e) { e.printStackTrace(); } } @Override public void run() { while (true) { try { String data = reader.readLine(); byte[] datas = data.getBytes(); DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(this.toIp, this.toPort)); socket.send(packet); if (data.equals(\"bye\")) { break; } } catch (Exception e) { e.printStackTrace(); } } socket.close(); }}ReceiverThread/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-10 22:24:18 * @LastEditTime: 2022-09-10 23:01:08 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /JavaWebPractice/TalkReceive.java */import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.SocketException;public class TalkReceive implements Runnable { private DatagramSocket socket; private String msgFrom; public TalkReceive(int port, String msgFrom) { this.msgFrom = msgFrom; try { socket = new DatagramSocket(port); } catch (SocketException e) { e.printStackTrace(); } } @Override public void run() { while (true) { try { // prepare to receive packet byte[] container = new byte[1024]; DatagramPacket packet = new DatagramPacket(container, 0, container.length); socket.receive(packet); // block to receive packet byte[] datas = packet.getData(); int len = packet.getLength(); String data = new String(datas, 0, len); System.out.println(msgFrom + \":\" + data + \" from address: \" + packet.getAddress()); // exit check if (data.equals(\"bye\")) { break; } } catch (Exception e) { e.printStackTrace(); } } socket.close(); }}Student/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-10 23:09:43 * @LastEditTime: 2022-09-10 23:20:04 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /JavaWebPractice/TalkStudent.java */public class TalkStudent { public static void main(String[] args) { new Thread(new TalkSend(7777, \"localhost\", 9999)).start(); new Thread(new TalkReceive(8888, \"è€å¸ˆ\")).start(); }}Teacher/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-10 23:10:56 * @LastEditTime: 2022-09-10 23:12:09 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /JavaWebPractice/TalkTeacher.java */public class TalkTeacher { public static void main(String[] args) { new Thread(new TalkReceive(9999, \"å­¦ç”Ÿ\")).start(); new Thread(new TalkSend(5555, \"localhost\", 8888)).start(); }}URLURL (Uniform Resource Locator): ç»Ÿä¸€èµ„æºå®šä½ç¬¦ï¼Œå®ƒè¡¨ç¤º internet ä¸ŠæŸä¸€èµ„æºçš„åœ°å€ã€‚å®ƒæ˜¯ä¸€ç§å…·ä½“çš„URIï¼Œå³URLå¯ä»¥ç”¨æ¥æ ‡è¯†ä¸€ä¸ªèµ„æºï¼Œè€Œä¸”è¿˜æŒ‡æ˜äº†å¦‚ä½•locate:å®šä½è¿™ä¸ªèµ„æºã€‚é€šè¿‡URL, æˆ‘ä»¬å¯ä»¥è®¿é—®Internetä¸Šçš„å„ç§ç½‘ç»œèµ„æºï¼Œæ¯”å¦‚æœ€å¸¸è§çš„ www, ftp ç«™ç‚¹ã€‚æµè§ˆå™¨é€šè¿‡è§£æç»™å®šçš„URLå¯ä»¥åœ¨ç½‘ç»œä¸ŠæŸ¥æ‰¾ç›¸åº”çš„æ–‡ä»¶æˆ–å…¶ä»–èµ„æºã€‚URLçš„åŸºæœ¬ç»“æ„ç”±5éƒ¨åˆ†ç»„æˆ:ä¼ è¾“åè®®://ä¸»æœºå:ç«¯å£å·/æ–‡ä»¶å #ç‰‡æ®µå?å‚æ•°åˆ—è¡¨URL Demo/* * @Author: Zeping Zhu * @Andrew ID: zepingz * @Date: 2022-09-11 00:30:43 * @LastEditTime: 2022-09-11 00:47:45 * @LastEditors: Zeping Zhu * @Description: * @FilePath: /JavaWebPractice/URLDemo01.java */import java.io.FileOutputStream;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.URL;public class URLDemo01 { public static void main(String[] args) { try { // 1. locate to ressource of server URL url = new URL(\"https://p1.music.126.net/7DYwgmJyEoTJZ3pyr7lixw==/109951167430870270.jpg?param=40y40\"); System.out.println(url.getProtocol()); //è·å–URLçš„åè®®å System.out.println(url.getHost()); //è·å–URLçš„ä¸»æœºå System.out.println(url.getPort()); //è·å–URLçš„ç«¯å£å· System.out.println(url.getPath()); //è·å–URLçš„æ–‡ä»¶è·¯å¾„ System.out.println(url.getFile()); //è·å–URLçš„æ–‡ä»¶å System.out.println(url.getQuery()); //è·å–URLçš„æŸ¥è¯¢å // 2. create connect HttpURLConnection connection = (HttpURLConnection) url.openConnection(); // 3. get inputStream InputStream is = connection.getInputStream(); // 4. write in file FileOutputStream fos = new FileOutputStream(\"icon.png\"); byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer)) != -1) { fos.write(buffer, 0, len); } // close fos.close(); is.close(); connection.disconnect(); System.out.println(\"closed...\"); } catch (Exception e) { e.printStackTrace(); } }}" }, { "title": "Foundations of Blockchains_18635 Note", "url": "/posts/SmallGame/", "categories": "Courses, Foundations of Blockchains_18635", "tags": "Blockchains", "date": "2022-08-31 02:30:00 +0000", "snippet": "An interesting card love dating game:Target: Alice and Bob, if both love each other, dating; otherwise, not datingPrerequisite:honest-but-curious, canâ€™t be â€˜maliciousâ€™Method 1:â¤ï¸: love â™£ï¸: not loveStep 1: Alice went into the room, puts card face-down on table, â¤ï¸ if love, â™£ï¸ if no loveStep 2: Alice leaves the room, Bob went into the room, if he loves Alice, open the card and get the result; otherwise, do nothing.Step 3: Bob return to tell Alice if they would date.It is like â€˜Andâ€™ function, only 1 will make an affect on the result. So if the person inputs 1, he/she should watch the otherâ€™s option; if the input is 0, then the result must be failure, so there is no need to watch the otherâ€™s choice and thus protecting the privacy of the other one that may have â¤ï¸.Method 2:Solution2Secure 2-party computationAlice and Bob want to learn some function on their joint inputs without disclosing their inputs, how to do it without cards? how to do it for any function?" }, { "title": "Markdown+Typoraå­¦ä¹ ç¬”è®°", "url": "/posts/typora/", "categories": "Tools Manual", "tags": "manual", "date": "2022-08-26 04:15:00 +0000", "snippet": "[TOC][Markdown+Typora/VSCode Manual]æ¥æº:Markdown-Typora-VSCode-DocğŸ˜‚ ç®€è¦ä»‹ç»Markdown æ˜¯ä¸€ç§è½»é‡å‹æ ‡è®°è¯­è¨€, æ˜¯ä¸€ç§è¯­æ³•. ä»¥ .md ç»“å°¾çš„æ–‡æœ¬æ–‡ä»¶å°±æ˜¯ Markdown æ–‡ä»¶. ç›¸è¾ƒäº Word, å®ƒæ›´åŠ åƒæ˜¯ HTML è¯­è¨€æˆ–æ˜¯ $\\LaTeX$, å¹¶ä¸æ˜¯æœ€æ·³æœ´çš„é‚£ç§â€æ‰€è§å³æ‰€å¾—â€. å®ƒå¤„å¤„é€éœ²ç€ä¸€ç§æç®€ä¸»ä¹‰. é«˜æ•ˆç®€æ´æ¸…æ™°çš„åŒæ—¶, åˆå¾ˆç®€å•. çœ‹èµ·æ¥èˆ’æœ, è¯­æ³•ç®€å•, å°¤å…¶åœ¨å¤„ç†çº¯æ–‡æœ¬ä¸Šæœ‰å¾ˆå¤§çš„ä¼˜åŠ¿.å®ƒç›¸è¾ƒäº Word, å…¼å®¹æ€§éå¸¸é«˜, å¯ä»¥è·¨å¹³å°ä½¿ç”¨, ä¸ç”¨æ‹…å¿ƒå¥‡å¥‡æ€ªæ€ªçš„ç‰ˆæœ¬å…¼å®¹é—®é¢˜. åŒæ—¶, æœ‰è®¸å¤šç½‘ç«™éƒ½æ”¯æŒæˆ–æ­£åœ¨ä½¿ç”¨ Markdown è¯­æ³•. å¦‚ Github (ç­‰ä¸€ç³»åˆ—ä»£ç æ‰˜ç®¡å¹³å°), StackOverflow(ç­‰ç­”ç–‘å¹³å°), ç®€ä¹¦, è¯­é›€ (ç­‰ä¸€ç³»åˆ—ç¬”è®°å¹³å°).ğŸ“ å®é™…åº”ç”¨æ‰€æœ‰è¦å†™æ–‡æœ¬çš„æ—¶å€™éƒ½å¯ä»¥ç”¨ä¸Š Markdown!å®ƒå¯ä»¥è®©ä½ ä¸å†çº ç»“ä»€ä¹ˆå­—ä½“, ä»€ä¹ˆæ ·å¼, ä»€ä¹ˆæ’ç‰ˆ. è€Œä¸”é€»è¾‘æ¸…æ™°, å±‚æ¬¡åˆ†æ˜.åƒæˆ‘å¤§ä¸€çš„æ—¶å€™å°±ç”¨ Markdown æ¥å†™å„ç§ç¬”è®°, æ¼”è®²ç¨¿, è¯¾ç¨‹è®ºæ–‡, å®éªŒæŠ¥å‘Š, ä»£ç çš„ README.md â€¦ åŒ…æ‹¬æœ¬æ•™ç¨‹æ–‡æ¡£.ğŸ´ å·¥å…·Markdown åªæ˜¯ä¸€ç§è¯­æ³•. é‚£ä¹ˆç”¨æ¥å†™ Markdown çš„æ–‡æœ¬ç¼–è¾‘å™¨å‘¢? æˆ‘æ¨èçš„æ˜¯ Typora æˆ–è€… VS CodeTyporaTypora åº”è¯¥æ˜¯è¢«å¹¿æ³›ç”¨äºå†™ Markdown çš„æ–‡æœ¬è½¯ä»¶, å°±å’Œ Markdown è¯­æ³•ä¸€æ ·é«˜æ•ˆ. è€Œä¸”å®ƒè¿˜æœ‰å¾ˆå®ç”¨çš„æ‰©å±•è¯­æ³•ä¸è‡ªå®šä¹‰æ ·å¼çš„åŠŸèƒ½. å…¶èƒ½å°† .md å¯¼å‡ºæˆå¤šç§æ–‡ä»¶, å¦‚ .pdf, .html, .docx (æ²¡æƒ³åˆ°å§, èƒ½å¯¼å‡ºåˆ° Word)ä½†æ˜¯ç°åœ¨ Typora å·²ç»å‘å¸ƒæ­£å¼ç‰ˆå¹¶ä¸”å˜ä¸ºæ”¶è´¹è½¯ä»¶. ä¸­æ–‡å®˜ç½‘åœ¨æ­¤ Typora å®˜æ–¹ä¸­æ–‡ç«™ .æˆ‘å½“ç„¶æ˜¯æ¨èå¤§å®¶éƒ½ç”¨æ­£ç‰ˆå•¦. ä¸è¿‡ä»·æ ¼æ˜¯æ°¸ä¹…ç‰ˆï¿¥89, å¥½åœ¨å¯ä»¥ç”¨åœ¨3å°è®¾å¤‡ä¸Š. å¦‚æœå’Œä½ çš„ä¸¤ä½åŒå­¦/èˆå‹å‡æ‘Šä¸€ä¸‹, æ¯äººå°±åªè¦ï¿¥30, å’Œä¸€å¼ æ¸¸æˆæœˆå¡å·®ä¸å¤š.è‡³äºç›—ç‰ˆä»¥åŠç ´è§£æ–¹æ³•åœ¨æ­¤éšä¾¿æ‰¾ä¸€ç§æ”¹æ³¨å†Œè¡¨æ—¶é—´æ–¹æ³•çš„ä¸ä»‹ç»(è¿˜æŒºå¤šçš„å…¶å®).è¿˜æœ‰ä¸€ç§å…è´¹ç™½å«–çš„æ–¹æ³•å°±æ˜¯å®‰è£…æµ‹è¯•ç‰ˆ/Betaç‰ˆ. å®˜ç½‘æœ‰å†å²ç‰ˆæœ¬çš„ä¸‹è½½é“¾æ¥ Typora å†å²ç‰ˆæœ¬ä¸‹è½½é¡µç™½å«–Betaç‰ˆå·²ç»å¯„äº†, è¦ä¹ˆæ”¯æŒæ­£ç‰ˆè¦ä¹ˆå»å­¦ä¹ ä¸€ä¸‹ç ´è§£æ–¹æ³•å§ (è¿˜æ˜¯å¿ä¸ä½å•¦, çœ‹ä¸Šé¢çš„é“¾æ¥ğŸ‘†)VS Codeè¿™æ˜¯å¾®è½¯å®¶çš„å¼€æºæ–‡æœ¬ç¼–è¾‘å™¨, ç†è®ºä¸Šæ¥è¯´æ‰€æœ‰ä»£ç , è¯­è¨€, éƒ½å¯ä»¥ç”¨ VS Code æ¥å†™, åŒæ ·æ˜¯éå¸¸çš„ç®€æ´å¥½ç”¨. åœ¨ä¸‹è½½æ’ä»¶ Markdown All in One åå¯¹ Markdown çš„åŸºç¡€æ”¯æŒä¹Ÿæ˜¯éå¸¸çš„å¥½. è‹¥åœ¨ VS Code ä¸‹è½½ Markdown å„ç§é™„åŠ æ‰©å±•, å°±èƒ½è·å¾—æ¯” Typora æ›´åŠ ä¸°å¯Œçš„æ‰©å±•è¯­æ³•ä¸æ“ä½œ.å…¶ä»–å¤§éƒ¨åˆ†IDE, åƒ Jetbrain çš„å…¨å®¶æ¡¶é‡Œåº”è¯¥æ¯ä¸€æ¬¾, éƒ½æ”¯æŒ Markdown è¯­æ³•, åœ¨æ­¤ä¸å¤šèµ˜è¿°.æœ¬æ–‡æ¡£ä¸»è¦ä½¿ç”¨ Typora è¿›è¡Œæ¼”ç¤º, åŒæ—¶ä¼šä»‹ç»è®¸å¤š Typora æ‰€åŒ…å«çš„æ‰©å±•è¯­æ³•.ğŸ­ åŸºç¡€æ•™ç¨‹å½“æœ‰å¤šç§æ ‡è®°æ–¹æ³•æ—¶æˆ‘ä¼šå€¾å‘å…¶ä¸­ä¸€ç§.æ ‡é¢˜æœ‰ * è¡¨ç¤ºè¯¥ä¸ºæ‰©å±•è¯­æ³•, ä»…åœ¨ Typora æˆ– æ·»åŠ äº†æ‰©å±•çš„ VS Code æœ¬åœ°ç”Ÿæ•ˆ, åœ¨å¤§å¤šæ•°å¹³å°ä¸Šå¹¶ä¸è®¤å¯.0. å†™ Markdown çš„ç¬¬é›¶æ­¥æˆ‘ä»¬å†™æ–‡æœ¬çš„æ—¶å€™å¤§å¤šå†™çš„æ˜¯ä¸­æ–‡, å¯æ˜¯è¾“å…¥æ³•åœ¨è¾“ä¸­æ–‡æ—¶ä½¿ç”¨çš„æ ‡ç‚¹ä¸ºå…¨è§’æ ‡ç‚¹, å¦‚ ï¼Œã€‚ï¼Ÿï¼ï¼ˆï¼‰ã€ã€‘ï¼šï¼›â€œâ€. è¿™äº›æ ‡ç‚¹æ˜¯ä¸è¢« Markdown æ‰€è®¤å¯çš„, ä¹Ÿæ˜¯æ— æ³•è½¬ä¹‰çš„.æˆ‘å»ºè®®å¤§å®¶å†™ Markdown çš„æ—¶å€™éƒ½ç”¨åŠè§’æ ‡ç‚¹, å³è‹±æ–‡æ ‡ç‚¹, å¦‚ ,.?!()[]:;\"\". ä¸”æ¯ä¸ªåŠè§’æ ‡ç‚¹åœ¨æ–‡æœ¬ä½¿ç”¨æ—¶åŠ ä¸Šåç½®ç©ºæ ¼, ç¬¦åˆè‹±æ–‡æ ‡ç‚¹çš„ä¹¦å†™è§„èŒƒ, ä¹Ÿæ›´åŠ ç¾è§‚.ä»¥å¾®è½¯è‡ªå¸¦è¾“å…¥æ³•ä¸¾ä¾‹, åœ¨ä½¿ç”¨ä¸­æ–‡è¾“å…¥æ³•æ—¶æŒ‰ä¸‹ Ctrl + .(è¿™æ˜¯ä¸ªå¥å·), åˆ‡æ¢æ ‡ç‚¹çš„å…¨è§’ä¸åŠè§’. è¿™æ ·å³å¯ä¸­æ–‡è¾“å…¥+åŠè§’æ ‡ç‚¹.1. æ ‡é¢˜ [æ•°ä¸ª â€œ#â€ + ç©ºæ ¼ å‰ç½®]# ä¸€çº§æ ‡é¢˜## äºŒçº§æ ‡é¢˜### ä¸‰çº§æ ‡é¢˜#### å››çº§æ ‡é¢˜##### äº”çº§æ ‡é¢˜###### å…­çº§æ ‡é¢˜æ ‡é¢˜ä¼šåœ¨ç›®å½•ä¸å¤§çº²åˆ†çº§æ˜¾ç¤º, å¯ä»¥è·³è½¬.åœ¨ Typora ä¸­å»ºè®®å¼€å¯ ä¸¥æ ¼æ¨¡å¼, å³ä¸åº”ä¸º #æ ‡é¢˜, åº”ä¸º # æ ‡é¢˜.åº”è¯¥è¦æ‰‹åŠ¨è¡¥ä¸Šç©ºæ ¼, ä½¿å¾— Markdown è¯­æ³•åœ¨å…¶ä»–æ–‡æœ¬ç¼–è¾‘å™¨ä¸Šå…¼å®¹.2. å¼ºè°ƒ [ç”¨ â€œ**â€ æˆ– â€œ__â€ åŒ…å›´]**æ¬¢è¿æŠ¥è€ƒå—äº¬å¤§å­¦!** (æˆ‘å–œæ¬¢ç”¨è¿™ç§)__æ¬¢è¿æŠ¥è€ƒå—äº¬å¤§å­¦!__æˆ–è€…é€‰ä¸­æƒ³è¦å¼ºè°ƒçš„æ–‡å­—æŒ‰ä¸‹ Ctrl + B.E.G.æ¬¢è¿æŠ¥è€ƒå—äº¬å¤§å­¦!3. æ–œä½“ [ç”¨ â€œ*â€ æˆ– â€œ_â€ åŒ…å›´]*æ¬¢è¿å¤§ä½¬æ¥æµ‡æµ‡æˆ‘å„ç§çŸ¥è¯†* (æˆ‘å–œæ¬¢ç”¨è¿™ç§)_æ¬¢è¿å¤§ä½¬æ¥æµ‡æµ‡æˆ‘å„ç§çŸ¥è¯†_æˆ–è€…é€‰ä¸­æƒ³è¦å¼ºè°ƒçš„æ–‡å­—æŒ‰ä¸‹ Ctrl + I.E.G.æ¬¢è¿å¤§ä½¬æ¥æµ‡æµ‡æˆ‘å„ç§çŸ¥è¯†(P.S. æ–œä½“å¹¶å¼ºè°ƒ [ç”¨ â€œ***â€ æˆ– â€œ___â€ åŒ…å›´])4. åˆ é™¤çº¿ [ç”¨ â€œ~~â€ åŒ…å›´]~~æˆ‘å®£å¸ƒä¸ªäº‹å„¿, æˆ‘æ˜¯Sabiyary!~~E.G.æˆ‘å®£å¸ƒä¸ªäº‹å„¿, æˆ‘æ˜¯Sabiyary!5. *é«˜äº® [ç”¨ â€œ==â€ åŒ…å›´](æ³¨æ„: æ­¤ä¸ºæ‰©å±•è¯­æ³•)==æˆ‘å–œæ¬¢é»„è‰², ä¹Ÿå–œæ¬¢ç»¿è‰²==E.G.==æˆ‘å–œæ¬¢é»„è‰², ä¹Ÿå–œæ¬¢ç»¿è‰²==6. ä»£ç  [ç”¨ â€œ`â€ åŒ…å›´]`sudo rm -rf /*`E.G.sudo rm -rf /* (æ²¡äº‹åˆ«ä¹±æ•²è¿™ä¸ª! )â€œè¯·è¾“å…¥ç®¡ç†å‘˜å¯†ç : (é—ªçƒçš„å…‰æ ‡)â€7. ä»£ç å— [æŒ‰ä¸‰ä¸ª â€œ`â€ å¹¶æ•²å›è½¦]```// è¿™é‡Œå°±å¯ä»¥å¼€å§‹è¾“å…¥ä½ è¦çš„ä»£ç äº†#include &lt;stdio.h&gt;int mian() { printï¼ˆâ€œHello, world!\\n\"ï¼‰; retrun O;}``` // (è¿™ä¸‰ä¸ª\"`\"æ–‡æœ¬ç¼–è¾‘å™¨ä¼šå¸®ä½ è‡ªåŠ¨è¡¥å…¨ ä¸€èˆ¬ä¸ç”¨æ‰‹åŠ¨è¾“)(æˆ‘ä¹‹å‰éƒ½æ˜¯ç”¨è¿™ä¸ªæ¥å±•ç¤ºå„ç§è¯­æ³•çš„, åº”è¯¥ä¸ç”¨ä¸¾ä¾‹äº†å§)è¦æƒ³æ˜¾ç¤ºè¡Œæ•°çš„è¯, ä¸€èˆ¬è¦åœ¨ Typora çš„è®¾ç½®é‡Œå‹¾ä¸Šè¿™ä¸ªæ˜¾ç¤ºè¡Œæ•°çš„é€‰é¡¹.ä»£ç å—é‡Œå¯ä»¥é€‰æ‹©è¯­è¨€, å…¶ä¼šæ ¹æ®è¯­è¨€æ¥è‡ªåŠ¨é«˜äº®å„ä¸ªè¯­å¥. åœ¨é€‰æ‹©è¯­è¨€å, ` ` ä¼šå˜ä¸º ` + å¯¹åº”è¯­è¨€.8. å¼•ç”¨ [â€&gt;â€ + ç©ºæ ¼ å‰ç½®]&gt; 24å², æ˜¯å­¦ç”Ÿ.&gt; &gt; å­¦ç”Ÿç‰¹æœ‰çš„æ— å¤„ä¸åœ¨(æ¼)å¼•ç”¨æ˜¯å¯ä»¥åµŒå¥—çš„!E.G. 24å², æ˜¯å­¦ç”Ÿ. å­¦ç”Ÿç‰¹æœ‰çš„æ— å¤„ä¸åœ¨(æ¼) 9. æ— åºåˆ—è¡¨ [â€-â€œ æˆ– â€œ+â€ + ç©ºæ ¼ å‰ç½®]- ä¸€é¢—æ˜¯æ£æ ‘ (æˆ‘å–œæ¬¢ç”¨è¿™ç§)+ å¦ä¸€é¢—è¿˜æ˜¯æ£æ ‘* (å…¶å®è¿™ç§ä¹Ÿå¯ä»¥, ä¸è¿‡ç”±äºåœ¨ Typora ä¸­å¾ˆéš¾å•ä¸ªè¾“å…¥, æ•…ä¸å¸¸ç”¨)ä¸‰ç§å‰ç½®ç¬¦éƒ½å¯ä»¥, æ•²å›è½¦ä¼šè‡ªåŠ¨è¡¥å…¨, å¯åœ¨ Typora è®¾ç½®ä¸­è°ƒæ•´è¡¥å…¨çš„ç¬¦å·, æ•²å›è½¦åæŒ‰ä¸‹ Tab ä¼šç¼©è¿›ä¸€çº§.E.G. ä¸€é¢—æ˜¯æ£æ ‘ å¦ä¸€é¢—è¿˜æ˜¯æ£æ ‘10. æœ‰åºåˆ—è¡¨ [æ•°å­— + â€œ.â€ + ç©ºæ ¼ å‰ç½®]æˆ‘æ¥è¿™é‡Œå°±ä¸ºäº†ä¸‰ä»¶äº‹:1. å…¬å¹³2. å…¬å¹³3. è¿˜æ˜¯tmçš„å…¬å¹³!æ•²å›è½¦ä¼šè‡ªåŠ¨è¡¥å…¨, æ•²å›è½¦åæŒ‰ä¸‹ Tab ä¼šç¼©è¿›ä¸€çº§.E.G.æˆ‘æ¥è¿™é‡Œå°±ä¸ºäº†ä¸‰ä»¶äº‹: å…¬å¹³ å…¬å¹³ è¿˜æ˜¯tmçš„å…¬å¹³!11. *ä¸Šæ ‡ [ç”¨ â€œ^â€ åŒ…å›´](æ³¨æ„: æ­¤ä¸ºæ‰©å±•è¯­æ³•)Cè¯­è¨€ä¸­intçš„ä¸Šé™æ˜¯ 2^31^ - 1 = 2147483647E.G.Cè¯­è¨€ä¸­ int çš„ä¸Šé™æ˜¯ 2^31^ - 1 = 214748364712. *ä¸‹æ ‡ [ç”¨ â€œ~â€ åŒ…å›´](æ³¨æ„: æ­¤ä¸ºæ‰©å±•è¯­æ³•)H~2~O æ˜¯å‰§æ¯’çš„!E.G.H~2~O æ˜¯å‰§æ¯’çš„!13. *æ³¨é‡Š [â€[^]â€ åç½®](æ³¨æ„: æ­¤ä¸ºæ‰©å±•è¯­æ³•)&gt; ä»Šæ—¥æˆ‘ä»¬ç›¸èšäºæ­¤, æ˜¯ä¸ºäº†å­¦ä¹  Markdown çš„ä½¿ç”¨, å®ƒçš„æ•™ç¨‹å¯¹äºå…¨ä½“ã€Œè§‚ä¼—ã€è€Œè¨€, å€¼å¾—è¶³è¶³ä¸¤ä¸ªç¡¬å¸çš„æ”¯æŒé¼“åŠ±![^1][^1]: æ²ƒå…¹Â·åŸºÂ·ç¡•å¾· æ”¹ç¼–è‡ªã€Œå…¬é¸¡ã€æ™®å¥‘æ¶…æ‹‰.éœ€è¦åœ¨æ–‡æœ«å†™ä¸Šæ³¨é‡Šå¯¹åº”çš„å†…å®¹E.G. ä»Šæ—¥æˆ‘ä»¬ç›¸èšäºæ­¤, æ˜¯ä¸ºäº†å­¦ä¹  Markdown çš„ä½¿ç”¨, å®ƒçš„æ•™ç¨‹å¯¹äºå…¨ä½“ã€Œè§‚ä¼—ã€è€Œè¨€, å€¼å¾—è¶³è¶³ä¸¤ä¸ªç¡¬å¸çš„æ”¯æŒé¼“åŠ±!114. é“¾æ¥ [å¸¸ç”¨ â€œ[ ]â€ + â€œ( )â€ åˆ†åˆ«åŒ…å›´æ–‡æœ¬ä¸é“¾æ¥](æ³¨æ„: æ–‡å†…è·³è½¬ä¸ºæ‰©å±•ç”¨æ³•)[æ¥çœ‹çœ‹æˆ‘è´«ç˜ çš„ä»“åº“ç½¢](https://github.com/Sakiyary)[åŸºç¡€æ•™ç¨‹: 12. ä¸‹æ ‡](#12. ä¸‹æ ‡ [ç”¨ \"~\" åŒ…å›´])æ”¯æŒç½‘é¡µé“¾æ¥ä¸æ–‡å†…è·³è½¬, æŒ‰ä½ Ctrl å¹¶ å•å‡»é¼ æ ‡å·¦é”® å³å¯è·³è½¬.E.G.æ¥çœ‹çœ‹æˆ‘è´«ç˜ çš„ä»“åº“ç½¢[åŸºç¡€æ•™ç¨‹: 12. ä¸‹æ ‡](#12. ä¸‹æ ‡ [ç”¨ â€œ~â€ åŒ…å›´])15. ä»»åŠ¡åˆ—è¡¨ [â€- [ ]â€ + ç©ºæ ¼ å‰ç½®]TodoList:- [ ] åˆ·Bç«™- [ ] å†™ä»£ç - [x] èµ·åºŠç”¨ x ä»£æ›¿ [ ] ä¸­çš„ç©ºæ ¼æ¥å‹¾é€‰ä»»åŠ¡åˆ—è¡¨. åœ¨ Typora ä¸­å¯ä»¥ç›´æ¥ç”¨é¼ æ ‡å·¦é”®å•å‡»å‹¾é€‰æ¡†.E.G. TodoList: åˆ·Bç«™ å†™ä»£ç  èµ·åºŠ16. è¡¨æ ¼ [ç”¨ â€œ|â€ ç»˜åˆ¶è¡¨æ ¼è¾¹æ¡†]| å­¦å· | å§“å | å¹´é¾„ || :--- | :---: | ---: | (å¼•å·çš„ä½ç½®ä»£è¡¨ç€ å·¦å¯¹é½, å±…ä¸­, å³å¯¹é½)|114514|ç”°æ‰€|24||1919810|æµ©ä¸‰|25|ç¬¬ä¸€è¡Œä¸ºè¡¨å¤´, å¹¶ç”±ç¬¬äºŒè¡Œåˆ†å‰²çº¿å†³å®šå¯¹é½æ–¹å¼ä¸é•¿åº¦, ç¬¬ä¸‰è¡ŒåŠä¹‹åå³è¡¨æ ¼æ•°æ®E.G. å­¦å· å§“å å¹´é¾„ 114514 ç”°æ‰€ 24 1919810 æµ©ä¸‰ 25 17. å›¾ç‰‡ [ç›´æ¥æ‹–è¿›æ¥æˆ–è€…å¤åˆ¶ç²˜è´´]![å›¾ç‰‡](å›¾ç‰‡çš„ä½ç½®)æˆ‘è¿˜æ˜¯ä¼šé€‰æ‹©æ‹–è¿›æ¥æˆ–è€…å¤åˆ¶ç²˜è´´å•¦~ åœ¨ Typora çš„è®¾ç½®é‡Œä¹Ÿå¯ä»¥æ”¹å›¾ç‰‡çš„å‚¨å­˜æ–¹å¼.18. åˆ†å‰²çº¿ [æŒ‰ä¸‰ä¸ª â€œ*â€ æˆ– â€œ-â€œ æˆ– â€œ_â€ å¹¶æ•²å›è½¦]***--- (æˆ‘å–œæ¬¢ç”¨è¿™ç§)___// (å…¶å®æŒ‰ä¸‰ä¸ªåŠä»¥ä¸Šéƒ½å¯ä»¥)ç”±äº * ä¸ _ å‡ä¼šè‡ªåŠ¨è¡¥å…¨, æ‰€ä»¥æˆ‘è§‰å¾— - æœ€ä¸ºæ–¹ä¾¿.E.G.19. Emojiè¡¨æƒ… [â€:â€ å‰ç½®](æ³¨æ„: è‹±æ–‡è¾“å…¥ä¸ºæ‰©å±•è¯­æ³•):sweat_smile: :drooling_face::clown_face:// (æ•²å›è½¦æˆ–è€…é¼ æ ‡ç‚¹å‡», åç½®çš„\":\"ä¸€èˆ¬ä¸éœ€è¦æ‰‹åŠ¨è¾“)è¿™ä¸ªåŠŸèƒ½å”¯ä¸€çš„è¦æ±‚å°±æ˜¯è‹±è¯­æ°´å¹³è¦é«˜, æˆ–è€…å¤§æ¦‚è®°å¾—å„ä¸ª Emoji çš„è‹±æ–‡å.E.G.:sweat_smile: :drooling_face::clown_face:å¯¹äºå…¶ä½™æ™®é€šçš„ Markdown æ–‡æœ¬ç¼–è¾‘å™¨, å¯ä»¥ç›´æ¥å°† Emoji è¡¨æƒ…å¤åˆ¶è¿›æ¥, è¿™æ˜¯ç›´æ¥ç¡¬ç¼–ç çš„ (åˆ»è¿›DNAé‡Œ)E.G.ğŸ˜…ğŸ¤¤ğŸ¤¡ç”¨å¥½è¿™ä¸ªåŠŸèƒ½å¯ä»¥è®©ä½ çš„æ–‡æœ¬éå¸¸çš„å¯çˆ±! å¤ªæŠ½è±¡äº†è¿™é‡Œåˆ†äº«ä¸€ä¸ªå¯ä»¥å¤åˆ¶å…¨Emojiçš„ç½‘ç«™, éå¸¸å¥½ç”¨! æˆ‘ä¹‹å‰çš„Cè¯­è¨€å¤§ä½œä¸šä¹Ÿæ˜¯ä»è¿™é‡Œä¸‹è½½çš„èµ„æº!ğŸ”¥ è¿›é˜¶æ•™ç¨‹1. ç›®å½• [è‡ªåŠ¨ç”Ÿæˆ][TOC] (æ­¤ä¸º Typora ç‰¹æœ‰çš„, å¦‚æœ¬æ–‡æ¡£å¼€å¤´)è‹¥ä½¿ç”¨ VS Code æ­é… Markdown All in One æ‰©å±•, å¯åœ¨ VS Code çš„å‘½ä»¤é¢æ¿ (å³ VS Code Command Palette) è¾“å…¥ Create Table of Contents è‡ªåŠ¨ç”Ÿæˆç›®å½•, ä¸”å¯åœ¨æ‰©å±•è®¾ç½®ä¸­ç»†è°ƒç›®å½•å‚æ•°.2. å†…è” HTML ä»£ç  [ç”¨ â€œ&lt;&gt; &lt;/&gt;â€ åŒ…å›´]&lt;div style=\"text-align:center\"&gt; &lt;font style=\"color:red\"&gt;æˆ‘ä¸ä¼š HTML å‘œå‘œå‘œ... æµ‡æµ‡æˆ‘&lt;/font&gt;&lt;/div&gt;&lt;center&gt;ç®€å•çš„æ–‡å­—å±…ä¸­ä¹Ÿå¯ä»¥è¿™æ ·&lt;/center&gt;&lt;u&gt;æˆ‘å·®ç‚¹å¿˜äº†è¿˜æœ‰ä¸‹åˆ’çº¿è¿™ä¸œè¥¿...&lt;/u&gt;åªè¦ä½ ä¼šå†™, ä½ å®Œå…¨å¯ä»¥æŠŠ Markdown å½“ä½œ HTML æ¥å†™.åŒæ—¶, .md æ–‡ä»¶å¯ä»¥ç›´æ¥å¯¼å‡ºæˆä¸€ä¸ªç½‘é¡µ.ä¸‹åˆ’çº¿å¯ä»¥é€‰ä¸­æƒ³è¦ä¸‹åˆ’çš„æ–‡å­—æŒ‰ä¸‹ Ctrl + U.E.G. æˆ‘ä¸ä¼š HTML å‘œå‘œå‘œ... æµ‡æµ‡æˆ‘ç®€å•çš„æ–‡å­—å±…ä¸­ä¹Ÿå¯ä»¥è¿™æ ·æˆ‘å·®ç‚¹å¿˜äº†è¿˜æœ‰ä¸‹åˆ’çº¿è¿™ä¸œè¥¿...3. å†…è” $\\LaTeX$ å…¬å¼ [ç”¨ â€œ$â€ åŒ…å›´](æ³¨æ„: éƒ¨åˆ†ç¼–è¯‘å™¨ä¼šä¸è¯†åˆ«éƒ¨åˆ†ç¬¦å·)$\\LaTeX$ æ˜¯æœ€å¥½ç”¨çš„è®ºæ–‡æ’ç‰ˆè¯­è¨€! ä¸ä¿¡ä½ çœ‹!$a^n+b^n=c^n$$$%\\usepackage{unicode-math}\\displaystyle \\ointctrclockwise\\mathcal{D}[x(t)]\\sqrt{\\frac{\\displaystyle3\\uppi^2-\\sum_{q=0}^{\\infty}(z+\\hat L)^{q}\\exp(\\symrm{i}q^2 \\hbar x)}{\\displaystyle (\\symsfup{Tr}\\symbfcal{A})\\left(\\symbf\\Lambda_{j_1j_2}^{i_1i_2}\\Gamma_{i_1i_2}^{j_1j_2}\\hookrightarrow\\vec D\\cdot \\symbf P \\right)}}=\\underbrace{\\widetilde{\\left\\langle \\frac{\\notin \\emptyset}{\\varpi\\alpha_{k\\uparrow}}\\middle\\vert\\frac{\\partial_\\mu T_{\\mu\\nu}}{2}\\right\\rangle}}_{\\mathrm{K}_3\\mathrm{Fe}(\\mathrm{CN})_6} ,\\forall z \\in \\mathbb{R}$$ç”¨ $ åŒ…å›´ä¸ºå•æ¡å…¬å¼, æŒ‰ä¸‹ä¸¤ä¸ª $ å¹¶æ•²å›è½¦å³ç”Ÿæˆå…¬å¼å—.E.G.$\\LaTeX$ æ˜¯æœ€å¥½ç”¨çš„è®ºæ–‡æ’ç‰ˆè¯­è¨€! ä¸ä¿¡ä½ çœ‹!$a^n+b^n=c^n$\\[%\\usepackage{unicode-math}\\displaystyle \\ointctrclockwise\\mathcal{D}[x(t)]\\sqrt{\\frac{\\displaystyle3\\uppi^2-\\sum_{q=0}^{\\infty}(z+\\hat L)^{q}\\exp(\\symrm{i}q^2 \\hbar x)}{\\displaystyle (\\symsfup{Tr}\\symbfcal{A})\\left(\\symbf\\Lambda_{j_1j_2}^{i_1i_2}\\Gamma_{i_1i_2}^{j_1j_2}\\hookrightarrow\\vec D\\cdot \\symbf P \\right)}}=\\underbrace{\\widetilde{\\left\\langle \\frac{\\notin \\emptyset}{\\varpi\\alpha_{k\\uparrow}}\\middle\\vert\\frac{\\partial_\\mu T_{\\mu\\nu}}{2}\\right\\rangle}}_{\\mathrm{K}_3\\mathrm{Fe}(\\mathrm{CN})_6} ,\\forall z \\in \\mathbb{R}\\]4. *ç½‘ç»œå›¾åºŠ(è¿™æ˜¯å­¦é•¿ç»™æˆ‘çš„ç½‘ç»œå›¾åºŠæ•™ç¨‹, æˆ‘å¹¶æœªå®è·µè¿‡â€¦)åˆ†äº«ä¸€ä¸ª Typora æ­é…è…¾è®¯äº‘COS/é˜¿é‡Œäº‘OSSå›¾åºŠçš„ä¾‹å­. æ–°ç”¨æˆ·å…è´¹è¯•ç”¨6ä¸ªæœˆ, å¦å¤–è¿˜å¯é€‰æ‹©ä¸ƒç‰›äº‘æˆ–è€…è·¯è¿‡å›¾åºŠ.5. *Typora çš„å¸¸ç”¨å¿«æ·é”® æŒ‰é”® æ•ˆæœ æŒ‰é”® æ•ˆæœ Ctrl + D é€‰ä¸­å½“å‰è¯ Ctrl + L é€‰ä¸­å½“å‰å¥/è¡Œ Ctrl + E é€‰ä¸­å½“å‰åŒºå— Ctrl + F æœç´¢å½“å‰é€‰ä¸­ Ctrl + B åŠ ç²—å½“å‰é€‰ä¸­ Ctrl + H æ›¿æ¢å½“å‰é€‰ä¸­ Ctrl + I å€¾æ–œå½“å‰é€‰ä¸­ Ctrl + U ä¸‹åˆ’å½“å‰é€‰ä¸­ Ctrl + K å°†å½“å‰é€‰ä¸­ç”Ÿæˆé“¾æ¥ Ctrl + J æ»šåŠ¨å±å¹•å°†é€‰ä¸­æ»šè‡³é¡¶éƒ¨ Ctrl + W å…³é—­å½“å‰çª—å£ Ctrl + N æ‰“å¼€æ–°çª—å£ Ctrl + O æ‰“å¼€æ–‡ä»¶ Ctrl + P æœç´¢æ–‡ä»¶å¹¶æ‰“å¼€ Ctrl + å›è½¦ è¡¨æ ¼ä¸‹æ–¹æ’å…¥è¡Œ Ctrl + , æ‰“å¼€åå¥½è®¾ç½® Ctrl + . åˆ‡æ¢å…¨è§’/åŠè§’æ ‡ç‚¹ Ctrl + / åˆ‡æ¢æ­£å¸¸/æºä»£ç è§†å›¾ Ctrl + Shift + - ç¼©å°è§†å›¾ç¼©æ”¾ Ctrl + Shift + + æ”¾å¤§è§†å›¾ç¼©æ”¾ è¿˜æœ‰ä¸€äº›ä¸å¸¸ç”¨çš„/ä¸‰é”®çš„å¿«æ·é”®ä¸åœ¨æ­¤åˆ—å‡º.6. *Typora çš„ä¸»é¢˜æ ·å¼ä¸æ£€æŸ¥å…ƒç´ Markdown åœ¨ç¼–è¯‘åçº¦ç­‰äº HTML. è€Œ Typora çš„æ­£å¸¸è§†å›¾å°±æ˜¯ç¼–è¯‘åçš„ Markdown, æ•…Typoraçš„ä¸»é¢˜æ ·å¼æœ¬è´¨å°±æ˜¯ CSS æ–‡ä»¶.å¯ä»¥ä¸‹è½½å„ç§å¥½çœ‹çš„ä¸»é¢˜ç»™ Typoraæ¢ä¸Š, åŒæ—¶ä¹Ÿå¯ä»¥è‡ªå·±è°ƒæ•´å¯¹åº”çš„ CSS æ–‡ä»¶, æˆ–è€…è‡ªå·±æ‰‹æ“.åœ¨ Typora è®¾ç½®ä¸­å¼€å¯ è°ƒè¯•æ¨¡å¼ åå³å¯åœ¨æ­£å¸¸è§†å›¾å³å‡»æ‰“å¼€ æ£€æŸ¥å…ƒç´ , åœ¨å…¶ä¸­å°±å¯ä»¥å®Œå…¨å°† Markdown æ–‡ä»¶å½“æˆ HTML æ¥ç¼–è¾‘.ğŸ’¯ æ€»ç»“è‡³æ­¤, Markdown + Typora / VSCode çš„æ‰‹å†Œæ•™ç¨‹ä¹Ÿå‘Šä¸€æ®µè½.ä¸çŸ¥ä½ çœ‹å®Œè¿™ä¹ˆé•¿çš„æ•™ç¨‹/æ‰‹å†Œ, æ˜¯å¦èƒ½ä½“ä¼šåˆ° Markdown çš„ç²¾å¦™ç®€æ´ä¹‹å¤„å‘¢?å…¶å® Markdown åªæ˜¯æ ‡è®°è¯­è¨€çš„æœ€å¼€å§‹, æˆ‘çš„æ„Ÿå—æ˜¯ä¼šäº† Markdown ä¹‹åå¯¹äºç†è§£ HTML ä¹Ÿæœ‰å¸®åŠ©, å¯¹äºç”¨ $\\LaTeX$ æ¥å†™è®ºæ–‡ä¹Ÿæœ‰å¸®åŠ©. æ ‡è®°è¯­è¨€æ­£æ˜¯ä¸ºäº†æ‘†è„± Word é‚£ç§è™½ç„¶â€æ‰€è§å³æ‰€å¾—â€, ä½†åˆè¿‡äºèŠ±å“¨æµ®å, å¾ˆå·®çš„å…¼å®¹æ€§ä¸é—­æºçš„ç¼–ç çš„ç¼ºé™·. å½“ä½ èƒ½æŒæ¡è¿™æ ·çš„â€æ‰€å†™å³æ‰€å¾—â€æ—¶, ä½ è‚¯å®šä¼šæ„Ÿå—åˆ°ç”¨ Markdown è¿™ç±»è¯­è¨€æ¥å¤„ç†æ–‡æœ¬çš„å¦™å¤„! æ²ƒå…¹Â·åŸºÂ·ç¡•å¾· æ”¹ç¼–è‡ªã€Œå…¬é¸¡ã€æ™®å¥‘æ¶…æ‹‰.Â &#8617; " }, { "title": "Leetcodeç¬”è®°ï¼ˆä¸€)", "url": "/posts/Leetcode1/", "categories": "Leetcode", "tags": "leetcode", "date": "2022-08-25 18:30:00 +0000", "snippet": "æµ‹è¯•ä¸€ä¸‹ä¸Šä¼ å›¾ç‰‡è·¯å¾„å¯ä»¥æ”¾å‡ºæ¥ä¹ˆï¼Github å¼€æºé¡¹ç›®æœç´¢ï¼šGitå¼€æºé¡¹ç›®æœç´¢" } ]
